"""
StandaloneCoPilot - Manufacturing Co-Pilot with Standalone Implementation
A FreeCAD macro that provides AI-powered manufacturing intelligence
with enhanced UI and cloud backend integration.

This version is completely standalone and doesn't rely on the existing modules,
implementing a strict singleton pattern to prevent multiple instances.
Cloud features (DFM, cost estimation, tool recommendations) are offloaded
to cloud services for lightweight operation.

Author: Samarjit
License: MIT
Version: 1.1.0 - Cloud Integration for DFM, Cost, and Tool Features
"""

import os
import sys
import json
import time
import random
import requests
import traceback
import re
import math
import urllib.request
import urllib.parse
from typing import Dict, List, Any, Optional, Tuple, Union, Callable
from datetime import datetime
from PySide2 import QtWidgets, QtCore, QtGui

# Try to import FreeCAD modules
try:
    import FreeCAD
    import Part
    import FreeCADGui
except ImportError:
    print("Error: Required modules not found. This macro requires PySide2 and FreeCAD.")
    raise

# Global singleton instance tracker
_STANDALONE_INSTANCE = None

# Add cloud services directory to path
_THIS_DIR = os.path.dirname(os.path.abspath(__file__))
if _THIS_DIR not in sys.path:
    sys.path.append(_THIS_DIR)

# Try to import cloud services
try:
    from cloud_services.cloud_integration import CloudIntegration
    from utils.cad_extractor import extract_cad_data_for_features
    _CLOUD_SERVICES_AVAILABLE = True
except ImportError:
    print("Warning: Cloud services not available. Some features will be disabled.")
    _CLOUD_SERVICES_AVAILABLE = False

# Try to import cloud integration functions
try:
    from cloud_integration_functions import (
        analyze_dfm, estimate_cost, recommend_tools, 
        compare_manufacturing_methods, call_feature
    )
    _CLOUD_FUNCTIONS_AVAILABLE = True
except ImportError:
    print("Warning: Cloud integration functions not available. Using built-in call_feature.")
    _CLOUD_FUNCTIONS_AVAILABLE = False

# ===============================
# Manufacturing Feature Manager
# ===============================
class ManufacturingFeatureManager:
    """Manages manufacturing features like DFM, cost estimation, and tool recommendations"""
    
    def __init__(self):
        """Initialize the manufacturing feature manager"""
        self.last_dfm_result = None
        self.last_cost_result = None
        self.last_tool_result = None
        self.cloud_integration = None
        
        # Try to initialize cloud integration
        if _CLOUD_SERVICES_AVAILABLE:
            try:
                from cloud_services.cloud_integration import CloudIntegration
                this_dir = os.path.dirname(os.path.abspath(__file__))
                config_path = os.path.join(this_dir, "cloud_config.json")
                self.cloud_integration = CloudIntegration(config_path)
                print("Cloud integration initialized for manufacturing features")
            except Exception as e:
                print(f"Error initializing cloud integration: {str(e)}")
                traceback.print_exc()
    
    def analyze_dfm(self, manufacturing_process="3d_printing"):
        """Analyze design for manufacturability"""
        try:
            # Use cloud integration if available
            if self.cloud_integration:
                result = self.cloud_integration.analyze_dfm(manufacturing_process)
                self.last_dfm_result = result
                return result
            # Otherwise use cloud functions if available
            elif _CLOUD_FUNCTIONS_AVAILABLE:
                result = analyze_dfm(manufacturing_process)
                self.last_dfm_result = result
                return result
            # Fall back to direct API call
            else:
                payload = {
                    "manufacturing_process": manufacturing_process,
                    "cad_data": extract_cad_data_for_features()
                }
                result = call_feature("dfm_analysis", payload)
                self.last_dfm_result = result
                return result
        except Exception as e:
            print(f"Error in DFM analysis: {str(e)}")
            traceback.print_exc()
            return {
                "success": False,
                "error": str(e),
                "service": "dfm",
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
            }
    
    def estimate_cost(self, manufacturing_process="3d_printing", material="pla", quantity=1, region="global"):
        """Estimate manufacturing cost"""
        try:
            # Use cloud integration if available
            if self.cloud_integration:
                result = self.cloud_integration.estimate_cost(
                    manufacturing_process=manufacturing_process,
                    material=material,
                    quantity=quantity,
                    region=region
                )
                self.last_cost_result = result
                return result
            # Otherwise use cloud functions if available
            elif _CLOUD_FUNCTIONS_AVAILABLE:
                result = estimate_cost(
                    manufacturing_process=manufacturing_process,
                    material=material,
                    quantity=quantity,
                    region=region
                )
                self.last_cost_result = result
                return result
            # Fall back to direct API call
            else:
                payload = {
                    "manufacturing_process": manufacturing_process,
                    "material": material,
                    "quantity": quantity,
                    "region": region,
                    "cad_data": extract_cad_data_for_features()
                }
                result = call_feature("cost_estimate", payload)
                self.last_cost_result = result
                return result
        except Exception as e:
            print(f"Error in cost estimation: {str(e)}")
            traceback.print_exc()
            return {
                "success": False,
                "error": str(e),
                "service": "cost",
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
            }
    
    def recommend_tools(self, manufacturing_process="cnc_machining", material="aluminum", machine_type=None):
        """Get tool recommendations"""
        try:
            # Use cloud integration if available
            if self.cloud_integration:
                result = self.cloud_integration.recommend_tools(
                    manufacturing_process=manufacturing_process,
                    material=material,
                    machine_type=machine_type
                )
                self.last_tool_result = result
                return result
            # Otherwise use cloud functions if available
            elif _CLOUD_FUNCTIONS_AVAILABLE:
                result = recommend_tools(
                    manufacturing_process=manufacturing_process,
                    material=material,
                    machine_type=machine_type
                )
                self.last_tool_result = result
                return result
            # Fall back to direct API call
            else:
                payload = {
                    "manufacturing_process": manufacturing_process,
                    "material": material,
                    "machine_type": machine_type,
                    "cad_data": extract_cad_data_for_features()
                }
                result = call_feature("tool_recommendation", payload)
                self.last_tool_result = result
                return result
        except Exception as e:
            print(f"Error in tool recommendation: {str(e)}")
            traceback.print_exc()
            return {
                "success": False,
                "error": str(e),
                "service": "tool_recommendation",
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
            }
    
    def compare_manufacturing_methods(self, materials=None, processes=None, quantities=None):
        """Compare costs across different manufacturing methods"""
        try:
            if materials is None:
                materials = ["pla", "abs", "nylon"]
            if processes is None:
                processes = ["3d_printing", "cnc_machining", "injection_molding"]
            if quantities is None:
                quantities = [1, 10, 100, 1000]
                
            # Use cloud integration if available
            if self.cloud_integration:
                return self.cloud_integration.compare_manufacturing_methods(
                    materials=materials,
                    processes=processes,
                    quantities=quantities
                )
            # Otherwise use cloud functions if available
            elif _CLOUD_FUNCTIONS_AVAILABLE:
                return compare_manufacturing_methods(
                    materials=materials,
                    processes=processes,
                    quantities=quantities
                )
            # Fall back to direct API call
            else:
                payload = {
                    "materials": materials,
                    "processes": processes,
                    "quantities": quantities,
                    "cad_data": extract_cad_data_for_features()
                }
                return call_feature("manufacturing_comparison", payload)
        except Exception as e:
            print(f"Error in manufacturing comparison: {str(e)}")
            traceback.print_exc()
            return {
                "success": False,
                "error": str(e),
                "service": "manufacturing_comparison",
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
            }
    
    def visualize_dfm_issues(self):
        """Visualize DFM issues in the FreeCAD view"""
        try:
            if self.cloud_integration:
                self.cloud_integration.visualize_dfm_issues()
            elif self.last_dfm_result and self.last_dfm_result.get("success", False):
                # Basic visualization if cloud integration not available
                issues = self.last_dfm_result.get("data", {}).get("issues", [])
                if not issues:
                    FreeCAD.Console.PrintMessage("No DFM issues to visualize\n")
                    return
                    
                # Create visualization objects
                doc = FreeCAD.ActiveDocument
                if not doc:
                    FreeCAD.Console.PrintError("No active document for visualization\n")
                    return
                    
                # Create a group for DFM issues
                dfm_group = doc.addObject("App::DocumentObjectGroup", "DFM_Issues")
                
                # Add visualization for each issue
                for i, issue in enumerate(issues):
                    issue_type = issue.get("type", "unknown")
                    position = issue.get("position", [0, 0, 0])
                    severity = issue.get("severity", "medium")
                    
                    # Create a sphere at the issue location
                    sphere = doc.addObject("Part::Sphere", f"DFM_Issue_{i+1}")
                    sphere.Radius = 2.0  # 2mm radius
                    sphere.Placement = FreeCAD.Placement(
                        FreeCAD.Vector(position[0], position[1], position[2]),
                        FreeCAD.Rotation()
                    )
                    
                    # Set color based on severity
                    if hasattr(sphere, "ViewObject"):
                        if severity == "high":
                            sphere.ViewObject.ShapeColor = (1.0, 0.0, 0.0)  # Red
                        elif severity == "medium":
                            sphere.ViewObject.ShapeColor = (1.0, 0.5, 0.0)  # Orange
                        else:
                            sphere.ViewObject.ShapeColor = (1.0, 1.0, 0.0)  # Yellow
                    
                    # Add to group
                    dfm_group.addObject(sphere)
                
                doc.recompute()
                FreeCAD.Console.PrintMessage(f"Visualized {len(issues)} DFM issues\n")
        except Exception as e:
            print(f"Error visualizing DFM issues: {str(e)}")
            traceback.print_exc()
    
    def visualize_tool_paths(self):
        """Visualize tool paths in the FreeCAD view"""
        try:
            if self.cloud_integration:
                self.cloud_integration.visualize_tool_paths()
            elif self.last_tool_result and self.last_tool_result.get("success", False):
                # Basic visualization if cloud integration not available
                tool_paths = self.last_tool_result.get("data", {}).get("tool_paths", [])
                if not tool_paths:
                    FreeCAD.Console.PrintMessage("No tool paths to visualize\n")
                    return
                    
                # Create visualization objects
                doc = FreeCAD.ActiveDocument
                if not doc:
                    FreeCAD.Console.PrintError("No active document for visualization\n")
                    return
                    
                # Create a group for tool paths
                path_group = doc.addObject("App::DocumentObjectGroup", "Tool_Paths")
                
                # Add visualization for each tool path
                for i, path in enumerate(tool_paths):
                    points = path.get("points", [])
                    tool_name = path.get("tool_name", f"Tool_{i+1}")
                    
                    if not points or len(points) < 2:
                        continue
                        
                    # Create a polyline for the tool path
                    polyline = []
                    for point in points:
                        polyline.append(FreeCAD.Vector(point[0], point[1], point[2]))
                    
                    # Create a wire from the points
                    wire = Part.makePolygon(polyline)
                    path_obj = doc.addObject("Part::Feature", f"Path_{tool_name}")
                    path_obj.Shape = wire
                    
                    # Set color and line width
                    if hasattr(path_obj, "ViewObject"):
                        path_obj.ViewObject.LineColor = (0.0, 0.0, 1.0)  # Blue
                        path_obj.ViewObject.LineWidth = 2.0
                    
                    # Add to group
                    path_group.addObject(path_obj)
                
                doc.recompute()
                FreeCAD.Console.PrintMessage(f"Visualized {len(tool_paths)} tool paths\n")
        except Exception as e:
            print(f"Error visualizing tool paths: {str(e)}")
            traceback.print_exc()

# Context manager for design context
class DesignContextManager:
    """Manage design context for natural language CAD"""
    
    def __init__(self):
        self.context = {
            'project': 'default',
            'process': 'any',
            'material': 'any',
            'units': 'mm',
            'current_objects': []
        }
    
    def update_context(self, key, value):
        """Update a context value"""
        self.context[key] = value
    
    def get_context(self):
        """Get the current context"""
        return self.context
    
    def add_object(self, obj):
        """Add an object to the current context"""
        if obj not in self.context['current_objects']:
            self.context['current_objects'].append(obj)
    
    def clear_objects(self):
        """Clear the current objects"""
        self.context['current_objects'] = []

# Cloud AI processor for natural language processing
class CloudAIProcessor:
    """Process natural language using cloud AI"""
    
    def __init__(self, cloud_client=None):
        self.cloud_client = cloud_client
        self.context_memory = []
        print(f"Debug: CloudAIProcessor initialized with client: {cloud_client is not None}")
    
    def process_advanced_command(self, text, context=None):
        """Process command with cloud AI"""
        if self.cloud_client and self.cloud_client.connected:
            return self.cloud_process(text, context)
        else:
            return self.local_process(text, context)
    
    def cloud_process(self, text, context):
        """Use cloud AI for processing"""
        try:
            if not self.cloud_client:
                print("Debug: No cloud client available, falling back to local processing")
                return self.local_process(text, context)
            
            # Build prompt with context
            prompt = self.build_ai_prompt(text, context)
            
            # Query cloud AI
            print(f"Debug: Using cloud client to process: {text}")
            response = self.cloud_client.get_chat_response(prompt)
            
            # Extract response text
            if "response" in response:
                response_text = response["response"]
                try:
                    # Try to parse as JSON
                    if '{' in response_text and '}' in response_text:
                        json_str = response_text[response_text.find('{'):response_text.rfind('}')+1]
                        parsed = json.loads(json_str)
                        return parsed
                    else:
                        return self.parse_text_response(response_text)
                except json.JSONDecodeError:
                    return self.parse_text_response(response_text)
            else:
                return self.local_process(text, context)
        except Exception as e:
            print(f"Cloud AI error: {e}")
            return self.local_process(text, context)
    
    def build_ai_prompt(self, text, context):
        """Build comprehensive prompt for AI"""
        ctx = context or {}
        prompt = f"""I need to create a CAD model based on this description: \"{text}\". 
        Please analyze this request and provide a structured response with the following information:
        
        1. What type of object should be created (e.g., bracket, gear, housing)
        2. The key dimensions and parameters needed
        3. Any specific features that should be added (e.g., holes, fillets)
        4. Any manufacturing constraints to consider
        
        Format your response as a JSON object with these keys: intent, object_type, parameters, features, constraints.
        For example: {{"intent": "create", "object_type": "bracket", "parameters": {{"length": 100, "width": 50, "height": 20}}, "features": ["mounting_holes", "fillets"], "constraints": ["3d_printable"]}}
        """
        
        return prompt
    
    def local_process(self, text, context):
        """Local processing with pattern matching"""
        text_lower = text.lower()
        print(f"Debug: Using local processing for: {text}")
        
        # Basic pattern matching
        result = {
            'intent': 'create',
            'object_type': self.extract_object_type(text),
            'parameters': self.extract_parameters(text),
            'features': [],
            'constraints': []
        }
        
        # Extract features
        if 'hole' in text_lower or 'drill' in text_lower:
            result['features'].append('holes')
        if 'fillet' in text_lower or 'round' in text_lower:
            result['features'].append('fillets')
        if 'chamfer' in text_lower or 'bevel' in text_lower:
            result['features'].append('chamfers')
        
        return result
    
    def extract_object_type(self, text):
        """Extract what type of object to create"""
        objects = ['bracket', 'gear', 'housing', 'enclosure', 'mount', 
                  'plate', 'shaft', 'spacer', 'frame', 'support', 'box', 'cylinder']
        
        text_lower = text.lower()
        for obj in objects:
            if obj in text_lower:
                return obj
        return 'box'  # Default to box
    
    def extract_parameters(self, text):
        """Extract dimensional parameters"""
        params = {}
        
        # Extract dimensions (100x50x20 format)
        dim_match = re.search(r'(\d+)\s*x\s*(\d+)(?:\s*x\s*(\d+))?', text)
        if dim_match:
            params['length'] = float(dim_match.group(1))
            params['width'] = float(dim_match.group(2))
            if dim_match.group(3):
                params['height'] = float(dim_match.group(3))
        else:
            # Default dimensions
            params['length'] = 100.0
            params['width'] = 50.0
            params['height'] = 20.0
        
        return params
    
    def parse_text_response(self, response):
        """Parse text response when JSON parsing fails"""
        result = {
            'intent': 'create',
            'object_type': 'box',
            'parameters': {'length': 100.0, 'width': 50.0, 'height': 20.0},
            'features': [],
            'constraints': []
        }
        
        # Try to extract key information from text
        object_match = re.search(r'object_?type:?\s*(\w+)', response, re.IGNORECASE)
        if object_match:
            result['object_type'] = object_match.group(1).lower()
        
        # Look for dimensions
        length_match = re.search(r'length:?\s*(\d+(?:\.\d+)?)', response, re.IGNORECASE)
        if length_match:
            result['parameters']['length'] = float(length_match.group(1))
            
        width_match = re.search(r'width:?\s*(\d+(?:\.\d+)?)', response, re.IGNORECASE)
        if width_match:
            result['parameters']['width'] = float(width_match.group(1))
            
        height_match = re.search(r'height:?\s*(\d+(?:\.\d+)?)', response, re.IGNORECASE)
        if height_match:
            result['parameters']['height'] = float(height_match.group(1))
            
        return result

# Natural Language CAD Editor
class NaturalLanguageCADEditor:
    """Natural Language CAD Editor"""
    
    def __init__(self, cloud_client=None):
        """Initialize the NL CAD editor"""
        self.cloud_client = cloud_client
        self.ai_processor = CloudAIProcessor(cloud_client)
        self.context = DesignContextManager()
        self.command_handlers = {}
        
        # Register command handlers
        self.register_command_handler('create', self.handle_create)
        self.register_command_handler('make', self.handle_create)
        self.register_command_handler('add', self.handle_create)
        self.register_command_handler('generate', self.handle_create)
        
        # Register advanced CAD handlers
        self.register_command_handler('gear', self.handle_gear)
        self.register_command_handler('extrude', self.handle_extrude)
        self.register_command_handler('fillet', self.handle_fillet)
        self.register_command_handler('cylinder', self.handle_cylinder)
    
    def register_command_handler(self, keyword, handler):
        """Register a command handler for a keyword"""
        self.command_handlers[keyword.lower()] = handler
    
    def process_command(self, text):
        """Process command with AI enhancement"""
        print(f"Processing CAD command: {text}")
        
        # Check if this is a complex command that needs AI processing
        if self.is_complex_command(text):
            # Use AI processor
            ai_spec = self.ai_processor.process_advanced_command(text, self.context.get_context())
            return self.create_from_ai_spec(ai_spec)
        
        # Simple command processing
        text_lower = text.lower()
        
        # Check for specific advanced commands first
        if 'extrude' in text_lower or 'extend' in text_lower or 'pull' in text_lower:
            print(f"Debug: Detected extrude command: {text}")
            return self.handle_extrude(text)
            
        if 'fillet' in text_lower or 'round' in text_lower or 'corner' in text_lower:
            print(f"Debug: Detected fillet command: {text}")
            return self.handle_fillet(text)
            
        if 'gear' in text_lower or 'cog' in text_lower:
            print(f"Debug: Detected gear command: {text}")
            return self.handle_gear(text)
            
        # Find matching handler for other commands
        for keyword, handler in self.command_handlers.items():
            if keyword in text_lower:
                print(f"Debug: Found handler for keyword: {keyword}")
                return handler(text)
        
        # Default to create handler if no match
        return self.handle_create(text)
    
    def handle_create(self, text):
        """Handle create commands"""
        try:
            # Extract parameters using AI processor
            params = self.ai_processor.local_process(text, self.context.get_context())
            
            # Get object type
            obj_type = params['object_type']
            dimensions = params['parameters']
            
            # Check for specific object types that need special handling
            if obj_type in ['gear']:
                return self.handle_gear(text)
                
            # Create the basic shape
            obj = None
            doc = FreeCAD.ActiveDocument or FreeCAD.newDocument("CADPart")
            
            if obj_type in ['box', 'cube', 'block']:
                length = dimensions.get('length', 100)
                width = dimensions.get('width', 50)
                height = dimensions.get('height', 20)
                
                box = Part.makeBox(length, width, height)
                obj = doc.addObject("Part::Feature", "Box")
                obj.Shape = box
            
            elif obj_type in ['cylinder', 'tube', 'rod', 'shaft']:
                radius = dimensions.get('radius', 10)
                if 'diameter' in dimensions:
                    radius = dimensions['diameter'] / 2
                height = dimensions.get('height', 50)
                
                cylinder = Part.makeCylinder(radius, height)
                obj = doc.addObject("Part::Feature", "Cylinder")
                obj.Shape = cylinder
            
            elif obj_type in ['sphere', 'ball']:
                radius = dimensions.get('radius', 25)
                if 'diameter' in dimensions:
                    radius = dimensions['diameter'] / 2
                
                sphere = Part.makeSphere(radius)
                obj = doc.addObject("Part::Feature", "Sphere")
                obj.Shape = sphere
            
            else:  # Default to box
                length = dimensions.get('length', 100)
                width = dimensions.get('width', 50)
                height = dimensions.get('height', 20)
                
                box = Part.makeBox(length, width, height)
                obj = doc.addObject("Part::Feature", obj_type.capitalize())
                obj.Shape = box
            
            # Commit changes
            doc.recompute()
            
            # Add features if specified
            if 'features' in params:
                for feature in params['features']:
                    if feature == 'holes':
                        # Add holes - simplified implementation
                        pass
                    elif feature == 'fillets':
                        self.add_fillets_to_object(obj, 2.0)  # Default 2mm radius
            
            return {'success': True, 'message': f"Created {obj_type}", 'object': obj}
            
        except Exception as e:
            print(f"Error creating object: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'message': f"Error: {str(e)}"}
    
    def is_complex_command(self, text):
        """Determine if command needs AI processing"""
        complex_indicators = [
            'with', 'that has', 'including', 'having',
            'assembly', 'mechanism', 'system',
            'compatible', 'optimized', 'analyze'
        ]
        
        text_lower = text.lower()
        return any(indicator in text_lower for indicator in complex_indicators)
    
    def create_from_ai_spec(self, ai_spec):
        """Create part from AI specification"""
        try:
            # Check if we have a valid spec
            if not ai_spec or not isinstance(ai_spec, dict):
                return {'success': False, 'message': "Invalid AI specification"}
                
            # Get object type
            obj_type = ai_spec.get('object_type', 'box')
            params = ai_spec.get('parameters', {})
            
            # Create the object
            result = None
            
            if obj_type == 'box':
                length = params.get('length', 100)
                width = params.get('width', 50)
                height = params.get('height', 20)
                
                doc = FreeCAD.ActiveDocument or FreeCAD.newDocument("CADPart")
                box = Part.makeBox(length, width, height)
                obj = doc.addObject("Part::Feature", "Box")
                obj.Shape = box
                doc.recompute()
                
                result = {'success': True, 'message': f"Created box with AI specifications", 'object': obj}
            
            elif obj_type == 'gear':
                teeth = params.get('teeth', 20)
                module = params.get('module', 2.0)
                width = params.get('width', 10.0)
                
                result = self.create_gear(teeth, module, width)
                
            elif obj_type == 'cylinder':
                radius = params.get('radius', 10.0)
                if 'diameter' in params:
                    radius = params['diameter'] / 2
                height = params.get('height', 50.0)
                
                doc = FreeCAD.ActiveDocument or FreeCAD.newDocument("CADPart")
                cylinder = Part.makeCylinder(radius, height)
                obj = doc.addObject("Part::Feature", "Cylinder")
                obj.Shape = cylinder
                doc.recompute()
                
                result = {'success': True, 'message': f"Created cylinder with AI specifications", 'object': obj}
                
            # Add more object types here
                
            if not result:
                return {'success': False, 'message': f"Unsupported object type: {obj_type}"}
                
            return result
            
        except Exception as e:
            print(f"Error creating from AI spec: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'message': f"Error: {str(e)}"}
            
    def handle_gear(self, text):
        """Create a gear based on text description"""
        try:
            print(f"Creating gear from: {text}")
            
            # Extract teeth count
            teeth_match = re.search(r'(\d+)\s*(?:tooth|teeth|toothed)', text, re.IGNORECASE)
            teeth = int(teeth_match.group(1)) if teeth_match else 20
            
            # Extract module if specified
            module_match = re.search(r'module\s*(\d+(?:\.\d+)?)', text, re.IGNORECASE)
            module = float(module_match.group(1)) if module_match else 2.0
            
            # Extract width if specified
            width_match = re.search(r'width\s*(\d+(?:\.\d+)?)', text, re.IGNORECASE)
            width = float(width_match.group(1)) if width_match else 10.0
            
            return self.create_gear(teeth, module, width)
            
        except Exception as e:
            print(f"Error creating gear: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'message': f"Error creating gear: {str(e)}"}
    
    def create_gear(self, teeth=20, module=2.0, width=10.0):
        """Create a gear with the specified parameters"""
        try:
            # Ensure we have an active document
            doc = FreeCAD.ActiveDocument
            if not doc:
                doc = FreeCAD.newDocument("Gear")
            
            # Calculate gear dimensions
            pitch_diameter = teeth * module
            outer_diameter = pitch_diameter + 2 * module  # Addendum
            root_diameter = pitch_diameter - 2.5 * module  # Dedendum
            
            # Create the base cylinder at the root diameter
            base_cylinder = Part.makeCylinder(root_diameter/2, width)
            
            # Create the teeth by adding blocks around the perimeter
            tooth_angle = 360.0 / teeth  # Angle between teeth
            tooth_width_angle = tooth_angle * 0.4  # Width of each tooth in degrees
            
            # Create a compound shape to hold all teeth
            all_teeth = []
            
            for i in range(teeth):
                # Calculate the angle for this tooth
                angle = i * tooth_angle
                
                # Create a tooth as a box
                tooth_height = (outer_diameter - root_diameter) / 2  # Radial height of tooth
                tooth_width = root_diameter * math.sin(math.radians(tooth_width_angle))  # Arc width at root diameter
                
                # Create the tooth as a box
                tooth = Part.makeBox(tooth_height, tooth_width, width)
                
                # Position the tooth at the edge of the root cylinder
                tooth.translate(FreeCAD.Vector(root_diameter/2, -tooth_width/2, 0))
                
                # Rotate the tooth to its position
                tooth.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 0, 1), angle)
                
                # Add to our collection
                all_teeth.append(tooth)
            
            # Fuse all teeth with the base cylinder
            gear_shape = base_cylinder
            for tooth in all_teeth:
                gear_shape = gear_shape.fuse(tooth)
            
            # Create a center bore
            bore = module * 5  # Reasonable bore size based on module
            center_hole = Part.makeCylinder(bore/2, width)
            gear_shape = gear_shape.cut(center_hole)
            
            # Create the final object
            gear_obj = doc.addObject("Part::Feature", f"Gear_T{teeth}_M{module}")
            gear_obj.Shape = gear_shape
            
            doc.recompute()
            
            return {
                'success': True,
                'message': f'Created gear: {teeth} teeth, module {module}, \u00f8{pitch_diameter:.1f}mm pitch diameter',
                'object': gear_obj,
                'specs': {
                    'teeth': teeth,
                    'module': module,
                    'pitch_diameter': pitch_diameter,
                    'outer_diameter': outer_diameter,
                    'root_diameter': root_diameter,
                    'width': width
                }
            }
            
        except Exception as e:
            print(f"Error creating gear: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'message': f"Error creating gear: {str(e)}"}
    
    def handle_cylinder(self, text):
        """Create a cylinder based on text description"""
        try:
            # Extract diameter/radius
            diameter_match = re.search(r'diameter\s*(\d+(?:\.\d+)?)', text, re.IGNORECASE)
            radius_match = re.search(r'radius\s*(\d+(?:\.\d+)?)', text, re.IGNORECASE)
            
            radius = 10.0  # Default
            if diameter_match:
                radius = float(diameter_match.group(1)) / 2
            elif radius_match:
                radius = float(radius_match.group(1))
            
            # Extract height/length
            height_match = re.search(r'(?:height|length)\s*(\d+(?:\.\d+)?)', text, re.IGNORECASE)
            height = float(height_match.group(1)) if height_match else 50.0
            
            # Create cylinder
            doc = FreeCAD.ActiveDocument or FreeCAD.newDocument("CADPart")
            cylinder = Part.makeCylinder(radius, height)
            obj = doc.addObject("Part::Feature", "Cylinder")
            obj.Shape = cylinder
            doc.recompute()
            
            return {'success': True, 'message': f"Created cylinder with radius {radius}mm and height {height}mm", 'object': obj}
            
        except Exception as e:
            print(f"Error creating cylinder: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'message': f"Error creating cylinder: {str(e)}"}
    
    def handle_extrude(self, text):
        """Handle extrusion commands with improved reliability"""
        try:
            print(f"Handling extrusion: {text}")
            print("Debug: ===== EXTRUDE OPERATION START =====")
            
            # Extract distance with better pattern matching
            distance_patterns = [
                r'(?:by|to|of)\s*(\d+(?:\.\d+)?)\s*(?:mm|millimeters?)?',
                r'(\d+(?:\.\d+)?)\s*(?:mm|millimeters?)',
                r'extrude.*?(\d+(?:\.\d+)?)',
            ]
            
            distance = 10.0  # Default
            for pattern in distance_patterns:
                distance_match = re.search(pattern, text, re.IGNORECASE)
                if distance_match:
                    distance = float(distance_match.group(1))
                    break
            
            print(f"Debug: Extrusion distance = {distance}mm")
            
            # Extract direction
            direction = 'up'  # Default direction
            if any(word in text.lower() for word in ['down', 'negative', 'inward', 'into']):
                direction = 'down'
            print(f"Debug: Extrusion direction = {direction}")
            
            # Ensure we have an active document
            if not FreeCAD.ActiveDocument:
                print("Debug: No active document, creating one")
                FreeCAD.newDocument("CADPart")
            
            doc = FreeCAD.ActiveDocument
            print(f"Debug: Active document is {doc.Name}")
            
            # Get selection
            try:
                selection = FreeCADGui.Selection.getSelectionEx()
                print(f"Debug: Found {len(selection)} selected objects")
                
                if not selection:
                    print("Debug: No selection found")
                    return {'success': False, 'message': 'Please select a face, sketch, or object to extrude first'}
                
            except Exception as sel_err:
                print(f"Debug: Selection error: {str(sel_err)}")
                return {'success': False, 'message': f'Selection error: {str(sel_err)}'}
            
            # Create extrusion vector
            if direction == 'down':
                extrude_vector = FreeCAD.Vector(0, 0, -distance)
            else:
                extrude_vector = FreeCAD.Vector(0, 0, distance)
            
            print(f"Debug: Extrusion vector: {extrude_vector}")
            
            # Process the selection
            success_count = 0
            error_messages = []
            
            for sel_item in selection:
                try:
                    obj = sel_item.Object
                    print(f"Debug: Processing object: {obj.Name} (Type: {obj.TypeId})")
                    
                    result_obj = None
                    
                    # Case 1: Face selection (most common for extrude commands)
                    if hasattr(sel_item, 'SubObjects') and sel_item.SubObjects:
                        print(f"Debug: Found {len(sel_item.SubObjects)} sub-objects")
                        
                        # Look for faces in the selection
                        faces = []
                        for sub_obj in sel_item.SubObjects:
                            if hasattr(sub_obj, 'Surface'):  # It's a face
                                faces.append(sub_obj)
                        
                        if faces:
                            print(f"Debug: Found {len(faces)} face(s) to extrude")
                            face = faces[0]  # Use the first face
                            
                            try:
                                print("Debug: Attempting direct face extrusion")
                                extruded_shape = face.extrude(extrude_vector)
                                
                                # Create new object
                                extrude_name = f"Extrude_{obj.Name}_{int(abs(distance))}mm"
                                result_obj = doc.addObject("Part::Feature", extrude_name)
                                result_obj.Shape = extruded_shape
                                result_obj.ViewObject.Visibility = True
                                
                                print(f"Debug: Successfully created face extrusion: {extrude_name}")
                                success_count += 1
                                
                            except Exception as face_err:
                                print(f"Debug: Direct face extrusion failed: {str(face_err)}")
                                error_messages.append(f"Face extrusion failed: {str(face_err)}")
                    
                    # Case 2: Sketch object
                    elif obj.TypeId == "Sketcher::SketchObject":
                        print("Debug: Processing sketch object")
                        try:
                            # Try to create a face from the sketch and extrude it
                            sketch_wires = obj.Shape.Wires
                            if sketch_wires:
                                wire = sketch_wires[0]
                                if wire.isClosed():
                                    face = Part.Face(wire)
                                    extruded_shape = face.extrude(extrude_vector)
                                    
                                    extrude_name = f"Extrude_{obj.Name}_{int(abs(distance))}mm"
                                    result_obj = doc.addObject("Part::Feature", extrude_name)
                                    result_obj.Shape = extruded_shape
                                    result_obj.ViewObject.Visibility = True
                                    
                                    print(f"Debug: Successfully created sketch extrusion: {extrude_name}")
                                    success_count += 1
                                else:
                                    error_messages.append(f"Sketch {obj.Name} is not closed")
                            else:
                                error_messages.append(f"Sketch {obj.Name} has no wires")
                                
                        except Exception as sketch_err:
                            print(f"Debug: Sketch processing failed: {str(sketch_err)}")
                            error_messages.append(f"Sketch processing failed: {str(sketch_err)}")
                    
                    # Case 3: Objects with faces (try to extrude the largest face)
                    elif hasattr(obj, 'Shape') and obj.Shape.Faces:
                        print("Debug: Processing object with faces")
                        try:
                            # Get the largest face (most likely the one to extrude)
                            largest_face = max(obj.Shape.Faces, key=lambda f: f.Area)
                            print(f"Debug: Using largest face with area {largest_face.Area}")
                            
                            extruded_shape = largest_face.extrude(extrude_vector)
                            
                            extrude_name = f"Extrude_{obj.Name}_{int(abs(distance))}mm"
                            result_obj = doc.addObject("Part::Feature", extrude_name)
                            result_obj.Shape = extruded_shape
                            result_obj.ViewObject.Visibility = True
                            
                            print(f"Debug: Successfully created object face extrusion: {extrude_name}")
                            success_count += 1
                            
                        except Exception as obj_err:
                            print(f"Debug: Object face extrusion failed: {str(obj_err)}")
                            error_messages.append(f"Object extrusion failed: {str(obj_err)}")
                    
                    else:
                        error_messages.append(f"Object {obj.Name} cannot be extruded (type: {obj.TypeId})")
                    
                except Exception as item_err:
                    print(f"Debug: Error processing selection item: {str(item_err)}")
                    error_messages.append(f"Processing error: {str(item_err)}")
            
            # Recompute document
            doc.recompute()
            
            # Update view
            if FreeCADGui.ActiveDocument:
                try:
                    FreeCADGui.ActiveDocument.ActiveView.viewAxometric()
                    FreeCADGui.updateGui()
                except:
                    pass  # View update is not critical
            
            # Return results
            if success_count > 0:
                message = f"Successfully extruded {success_count} item(s) by {distance}mm {direction}"
                if error_messages:
                    message += f" (with {len(error_messages)} errors)"
                
                print(f"Debug: {message}")
                print("Debug: ===== EXTRUDE OPERATION COMPLETE =====")
                return {'success': True, 'message': message}
            else:
                error_summary = "; ".join(error_messages) if error_messages else "Unknown error"
                print(f"Debug: No extrusions created. Errors: {error_summary}")
                print("Debug: ===== EXTRUDE OPERATION FAILED =====")
                return {'success': False, 'message': f'No extrusions created. {error_summary}'}
                
        except Exception as e:
            print(f"Error during extrusion: {str(e)}")
            traceback.print_exc()
            print("Debug: ===== EXTRUDE OPERATION FAILED =====")
            return {'success': False, 'message': f"Error during extrusion: {str(e)}"}
    
    def handle_fillet(self, text):
        """Handle fillet commands"""
        try:
            print(f"Handling fillet: {text}")
            
            # Extract radius
            radius_match = re.search(r'(?:radius|of)\s*(\d+(?:\.\d+)?)\s*(?:mm)?', text, re.IGNORECASE)
            radius = float(radius_match.group(1)) if radius_match else 2.0
            print(f"Debug: Fillet radius = {radius}mm")
            
            # Check if edges are selected
            try:
                selection = FreeCADGui.Selection.getSelectionEx()
                print(f"Debug: Found {len(selection)} selected objects")
                
                if not selection:
                    # If no selection, try to select the most recently created object
                    doc = FreeCAD.ActiveDocument
                    if doc and len(doc.Objects) > 0:
                        # Get the last created object
                        last_obj = doc.Objects[-1]
                        print(f"Debug: Auto-selecting last created object: {last_obj.Name}")
                        FreeCADGui.Selection.addSelection(last_obj)
                        selection = FreeCADGui.Selection.getSelectionEx()
                    else:
                        print("Debug: No objects in document to select")
                        return {'success': False, 'message': 'Please select an object or edges first'}
            except Exception as sel_err:
                print(f"Debug: Error during selection: {str(sel_err)}")
                traceback.print_exc()
                return {'success': False, 'message': f"Selection error: {str(sel_err)}"}
            
            results = []
            for sel_obj in selection:
                obj = sel_obj.Object
                print(f"Debug: Processing object for fillet: {obj.Name}")
                
                if not hasattr(obj, 'Shape') or not hasattr(obj.Shape, 'Edges') or len(obj.Shape.Edges) == 0:
                    print(f"Debug: Object {obj.Name} has no edges to fillet")
                    continue
                    
                print(f"Debug: Object has {len(obj.Shape.Edges)} edges")
                
                # Check if specific edges are selected
                selected_edges = []
                if hasattr(sel_obj, 'SubElementNames') and sel_obj.SubElementNames:
                    print(f"Debug: Found {len(sel_obj.SubElementNames)} sub-elements")
                    for sub in sel_obj.SubElementNames:
                        if sub.startswith('Edge'):
                            edge_idx = int(sub.replace('Edge', '')) - 1
                            selected_edges.append(edge_idx)
                            print(f"Debug: Selected edge {edge_idx}")
                
                # If no specific edges selected, use all edges
                if not selected_edges:
                    print("Debug: No specific edges selected, using all edges")
                    selected_edges = list(range(len(obj.Shape.Edges)))
                
                if not selected_edges:
                    print(f"Debug: No edges found for object {obj.Name}")
                    continue
                
                try:
                    # Create fillet
                    fillet_name = f"Fillet_{obj.Name}"
                    print(f"Debug: Creating fillet object {fillet_name}")
                    fillet = FreeCAD.ActiveDocument.addObject("Part::Fillet", fillet_name)
                    fillet.Base = obj
                    
                    # Add edges to fillet
                    edge_strings = []
                    for edge_idx in selected_edges:
                        if edge_idx < len(obj.Shape.Edges):
                            edge_strings.append((edge_idx+1, radius, radius))
                    
                    print(f"Debug: Adding {len(edge_strings)} edges to fillet")
                    fillet.Edges = edge_strings
                    
                    # Hide original object
                    if hasattr(FreeCADGui, "ActiveDocument") and FreeCADGui.ActiveDocument:
                        try:
                            FreeCADGui.ActiveDocument.getObject(obj.Name).Visibility = False
                            print(f"Debug: Set original object {obj.Name} visibility to False")
                        except Exception as vis_err:
                            print(f"Debug: Error setting visibility: {str(vis_err)}")
                    
                    results.append({
                        'object': fillet,
                        'radius': radius,
                        'edges': len(edge_strings)
                    })
                    print(f"Debug: Successfully added fillet to results")
                except Exception as fillet_err:
                    print(f"Debug: Error creating fillet: {str(fillet_err)}")
                    traceback.print_exc()
            
            # Recompute document
            FreeCAD.ActiveDocument.recompute()
            
            if not results:
                return {'success': False, 'message': 'No fillets were created'}
                
            return {
                'success': True,
                'message': f'Created {len(results)} fillet(s) with radius {radius}mm',
                'fillets': results
            }
            
        except Exception as e:
            print(f"Error creating fillet: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'message': f"Error creating fillet: {str(e)}"}
    
    def add_fillets_to_object(self, obj, radius=2.0):
        """Add fillets to all edges of an object"""
        try:
            if not obj or not hasattr(obj, 'Shape') or not hasattr(obj.Shape, 'Edges'):
                return False
                
            # Create fillet
            fillet_name = f"Fillet_{obj.Name}"
            fillet = FreeCAD.ActiveDocument.addObject("Part::Fillet", fillet_name)
            fillet.Base = obj
            
            # Add all edges to fillet
            edge_strings = []
            for i in range(len(obj.Shape.Edges)):
                edge_strings.append((i+1, radius, radius))
            
            fillet.Edges = edge_strings
            
            # Hide original object
            if hasattr(FreeCADGui, "ActiveDocument") and FreeCADGui.ActiveDocument:
                FreeCADGui.ActiveDocument.getObject(obj.Name).Visibility = False
            
            # Recompute document
            FreeCAD.ActiveDocument.recompute()
            
            return True
            
        except Exception as e:
            print(f"Error adding fillets: {str(e)}")
            return False

class CloudApiClient:
    """Client for communicating with the Manufacturing Co-Pilot Cloud API"""
    
    # Default endpoint for CAD analysis
    default_analysis_endpoint = "/api/analysis/cad"
    
    @classmethod
    def load_cloud_config(cls):
        """Load cloud configuration from JSON file if available"""
        try:
            # Check for config file in the same directory as this script
            script_dir = os.path.dirname(os.path.realpath(__file__))
            config_file = os.path.join(script_dir, "cloud_config.json")
            
            if os.path.exists(config_file):
                print(f"Loading cloud configuration from {config_file}")
                with open(config_file, "r") as f:
                    cloud_config = json.load(f)
                
                # Update default endpoint if specified
                if "default_analysis_endpoint" in cloud_config:
                    cls.default_analysis_endpoint = cloud_config["default_analysis_endpoint"]
                    print(f"Using custom analysis endpoint: {cls.default_analysis_endpoint}")
                
                return cloud_config
            else:
                print("No cloud_config.json file found, using defaults")
                return {}
        except Exception as e:
            print(f"Error loading cloud configuration: {e}")
            return {}
    
    def __init__(self, api_url: str = None, api_key: str = None):
        """Initialize the cloud API client"""
        # Load cloud configuration
        cloud_config = self.load_cloud_config()
        
        # Store the entire config in the instance
        self.config = cloud_config
        
        # Set API URL and key from config or parameters
        self.api_url = api_url or cloud_config.get("cloud_api_url", "https://freecad-copilot-service-501520737043.asia-south1.run.app")
        self.api_key = api_key or cloud_config.get("cloud_api_key", "dev_api_key_for_testing")
        self.default_analysis_endpoint = self.default_analysis_endpoint or cloud_config.get("default_analysis_endpoint", "/api/analysis/cad")
        self.timeout = cloud_config.get("connection_timeout", 10)  # Default timeout in seconds
        
        # Print debug info about DFM endpoint
        if "dfm_endpoint" in cloud_config:
            print(f"DEBUG: Loaded DFM endpoint from config: {cloud_config['dfm_endpoint']}")
        else:
            print("DEBUG: No DFM endpoint found in config")
            # Add default DFM endpoint if not present
            # Use the analysis endpoint for DFM since the dedicated DFM endpoint doesn't exist
            self.config["dfm_endpoint"] = "/api/analysis/cad"
        self.last_error = None
        self.connected = False
        self.connection_quality = "unknown"  # unknown, poor, fair, good, excellent
        self.last_latency = 0  # in ms
        self.last_check_time = 0
        self.connection_listeners = []  # callbacks for connection status changes
        
        # Test connection on init
        self.test_connection()
    
    def test_connection(self) -> bool:
        """Test connection to the cloud API"""
        try:
            # Load timeout from config or use default
            cloud_config = self.load_cloud_config()
            timeout = cloud_config.get("connection_timeout", 10)
            retry_count = cloud_config.get("retry_count", 3)
            
            # Only use the known working endpoint to avoid 404 errors
            endpoints_to_try = ["/health"]
            
            print(f"Testing connection with endpoint: {endpoints_to_try[0]}")
            
            # Try each endpoint with retries
            for endpoint in endpoints_to_try:
                for attempt in range(retry_count):
                    try:
                        start_time = time.time()
                        response = self._make_request(endpoint, method="GET", timeout=timeout)
                        end_time = time.time()
                        
                        # Calculate latency in milliseconds
                        latency = int((end_time - start_time) * 1000)
                        self.last_latency = latency
                        self.last_check_time = time.time()
                        
                        # Determine connection quality based on latency
                        if latency < 200:
                            self.connection_quality = "excellent"
                        elif latency < 500:
                            self.connection_quality = "good"
                        elif latency < 1000:
                            self.connection_quality = "fair"
                        else:
                            self.connection_quality = "poor"
                            
                        # Connection successful
                        old_status = self.connected
                        self.connected = True
                        
                        # Notify listeners if status changed
                        if not old_status and self.connected:
                            self._notify_connection_change()
                            
                        return True
                    except Exception as e:
                        print(f"Attempt {attempt+1}/{retry_count} failed for endpoint {endpoint}: {str(e)}")
                        if attempt == retry_count - 1:
                            continue  # Try next endpoint
                        time.sleep(0.5)  # Brief delay between retries
            
            # If we get here, all endpoints failed
            self.last_error = "Failed to connect to cloud API"
            old_status = self.connected
            self.connected = False
            self.connection_quality = "poor"  # Set to poor instead of unknown for UI clarity
            
            # Try one more time with the default API key
            print("Trying connection with default API key...")
            self.api_key = "dev_api_key_for_testing"
            
            # Try the most reliable endpoint with the default key
            try:
                response = self._make_request("/health", method="GET", timeout=timeout)
                print("Connection successful with default API key")
                self.connected = True
                self.connection_quality = "fair"
                
                # Update the config file with the working API key
                if hasattr(self, 'config'):
                    self.config["cloud_api_key"] = self.api_key
                    self._save_config_to_file()
                    
                # Notify listeners of the connection change
                self._notify_connection_change()
                return True
            except Exception as e:
                print(f"Connection with default API key also failed: {str(e)}")
            
            # Notify listeners if status changed
            if old_status and not self.connected:
                self._notify_connection_change()
            
            return False
        except Exception as e:
            self.last_error = str(e)
            old_status = self.connected
            self.connected = False
            self.connection_quality = "unknown"
            
            # Notify listeners if status changed
            if old_status and not self.connected:
                self._notify_connection_change()
            
            return False
    
    def get_chat_response(self, message: str) -> Dict[str, Any]:
        """Get a response from the cloud API for a chat message"""
        try:
            # Get active document info if available
            cad_data = self._get_cad_data()
            
            # Check if this is a DFM analysis request
            message_lower = message.lower()
            dfm_terms = [
                "dfm", 
                "check for manufacturability",
                "design for manufacturing",
                "manufacturable",
                "3d print",
                "3d printing",
                "printable",
                "can this be printed",
                "can this be manufactured",
                "cnc",
                "machining",
                "machinable",
                "manufacturing issues",
                "manufacturing problems",
                "manufacturing constraints",
                "check this part"
            ]
            # Log the message for debugging
            print(f"DEBUG: Checking if message is DFM request: '{message}'")
            
            # Check if any DFM term is in the message
            is_dfm_request = any(term in message_lower for term in dfm_terms)
            print(f"DEBUG: Is DFM request: {is_dfm_request}")
            
            # Prepare payload for analysis endpoint
            payload = {
                "message": message,
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S"),
                "mode": "general",
                "cad_data": cad_data
            }
            
            # Determine which endpoint to use
            endpoint = self.default_analysis_endpoint
            
            # Debug config information
            print(f"DEBUG: Has config attribute: {hasattr(self, 'config')}")
            if hasattr(self, 'config'):
                print(f"DEBUG: Config keys: {list(self.config.keys())}")
                print(f"DEBUG: DFM endpoint in config: {'dfm_endpoint' in self.config}")
                if 'dfm_endpoint' in self.config:
                    print(f"DEBUG: DFM endpoint value: {self.config['dfm_endpoint']}")
            
            # If this is a DFM request and dfm_endpoint is configured, use it
            if is_dfm_request:
                print("DEBUG: This is a DFM request")
                if hasattr(self, 'config') and 'dfm_endpoint' in self.config:
                    print(f"DEBUG: Using DFM endpoint: {self.config['dfm_endpoint']}")
                    endpoint = self.config['dfm_endpoint']
                else:
                    print("DEBUG: No DFM endpoint configured, using default endpoint")
            else:
                print("DEBUG: Not a DFM request, using default endpoint")
            
            # Prepare the appropriate payload based on the endpoint
            request_payload = payload
            
            # If this is a DFM request, format the payload appropriately
            if is_dfm_request:
                print("DEBUG: Formatting payload for DFM endpoint")
                
                # Format payload for the new DFM endpoint structure
                print("DEBUG: Formatting payload for new DFM endpoint structure")
                
                # Extract CAD data
                if 'cad_data' not in payload:
                    print("ERROR: Missing cad_data in payload")
                    payload['cad_data'] = {}
                
                cad_data = payload['cad_data']
                part_name = cad_data.get('name', 'Unknown Part')
                
                # Default values
                material = cad_data.get('material', 'ABS')
                process = 'fdm'  # Default to FDM 3D printing
                
                # Extract manufacturing intent from message if available
                message = payload.get('message', '').lower()
                
                # More detailed process detection
                if 'cnc' in message or 'machining' in message or 'milling' in message:
                    process = 'cnc'
                    print(f"DEBUG: Detected CNC machining process from query: '{message}'")
                elif '3d print' in message or 'fdm' in message or 'printing' in message or 'printed' in message:
                    process = 'fdm'
                    print(f"DEBUG: Detected 3D printing process from query: '{message}'")
                elif 'injection' in message or 'molding' in message or 'moulding' in message:
                    process = 'injection_molding'
                    print(f"DEBUG: Detected injection molding process from query: '{message}'")
                
                print(f"DEBUG: Selected manufacturing process: {process}")
                
                # Extract features from CAD data
                features = []
                
                # Add walls if we have thickness information
                if 'dimensions' in cad_data and 'thickness' in cad_data['dimensions']:
                    features.append({
                        "type": "wall",
                        "dimensions": {"thickness": cad_data['dimensions'].get('thickness', 1.5)},
                        "geometry_ref": {"face_index": None}
                    })
                
                # Add fillets if we have radius information
                if 'manufacturing_features' in cad_data and 'min_fillet_radius' in cad_data['manufacturing_features']:
                    features.append({
                        "type": "fillet",
                        "dimensions": {"radius": cad_data['manufacturing_features'].get('min_fillet_radius', 0.5)},
                        "geometry_ref": {"edge_index": None}
                    })
                
                # Add holes if we have any in the features
                if 'manufacturing_features' in cad_data and 'holes' in cad_data['manufacturing_features']:
                    hole_count = cad_data['manufacturing_features'].get('holes', 0)
                    if hole_count > 0:
                        features.append({
                            "type": "hole",
                            "dimensions": {"diameter": 2.0},  # Default diameter
                            "geometry_ref": {"face_index": None}
                        })
                
                # Create the DFM-specific payload that works with both endpoints
                dfm_data = {
                    "material": material,
                    "process": process,
                    "features": features,
                    "tolerances": {"general": 0.1},
                    "surface_finish": "normal"
                }
                
                # Integrate DFM data into the standard payload format
                request_payload = {
                    "message": payload["message"],
                    "timestamp": payload["timestamp"],
                    "mode": "dfm",  # Set mode to dfm
                    "cad_data": payload["cad_data"],
                    "dfm_data": dfm_data,  # Add the DFM-specific data
                    "analysis_type": "dfm",
                    "manufacturing_process": process,  # Explicitly specify the manufacturing process
                    "query_intent": {
                        "process_specific": True,
                        "process_type": process,
                        "original_query": payload["message"]
                    }
                }
                
                print(f"DEBUG: New DFM payload: {request_payload}")
                print(f"DEBUG: Enhanced payload for DFM: {request_payload}")
                print(f"DEBUG: DFM payload: {request_payload}")
            
            # Try the selected endpoint with retries
            max_retries = 3
            retry_delay = 1  # seconds
            
            # For DFM requests, use the dedicated endpoint if available
            if is_dfm_request:
                # Check if we should use the new dedicated DFM endpoint
                if self.config.get('use_dedicated_dfm_endpoint', False) and '/check_dfm' in self.config.get('dfm_endpoint', ''):
                    # Use the dedicated endpoint without query parameters
                    print(f"DEBUG: Using dedicated DFM endpoint: {endpoint}")
                else:
                    # Fall back to the analysis endpoint with query parameters
                    endpoint = f"{endpoint}?analysis_type=dfm&process={process}"
                    print(f"DEBUG: Using analysis endpoint with DFM and process parameters: {endpoint}")
            
            for attempt in range(1, max_retries + 1):
                try:
                    if attempt > 1:
                        print(f"Retry attempt {attempt}/{max_retries} for endpoint {endpoint}")
                    response = self._make_request(endpoint, payload=request_payload)
                    # If successful, update connection status
                    if not self.connected:
                        old_status = self.connected
                        self.connected = True
                        if old_status != self.connected:
                            self._notify_connection_change()
                
                    # For DFM requests, format the response appropriately
                    if is_dfm_request:
                        print("DEBUG: Formatting DFM response")
                        print(f"DEBUG: Response keys: {response.keys() if isinstance(response, dict) else 'Not a dict'}")                        
                        # Get part name from payload
                        part_name = "Unknown Part"
                        original_query = ""
                        if isinstance(payload, dict):
                            if 'cad_data' in payload:
                                part_name = payload['cad_data'].get('name', 'Unknown Part')
                            elif 'material' in payload and 'features' in payload:
                                # This is the new DFM payload format
                                part_name = "Part"
                            
                            # Store the original query for context
                            original_query = payload.get('message', '')
                            
                        # Add the original query to the response for context
                        if isinstance(response, dict) and original_query:
                            response['original_query'] = original_query
                        
                        # Create a DFM-specific response
                        if isinstance(response, dict):
                            # Check if this is a response from the new DFM endpoint
                            if 'violations' in response:
                                print("DEBUG: Found violations data in response (new DFM format)")
                                dfm_response = {
                                    "response": self._format_dfm_response(response, part_name),
                                    "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
                                }
                                return dfm_response
                            # Check if this is an analysis result with manufacturability data (legacy format)
                            elif 'manufacturability_index' in response or 'design_issues' in response:
                                print("DEBUG: Found manufacturability data in response (legacy format)")
                                
                                # Determine if this is a process-specific query
                                process_type = ''
                                if original_query:
                                    if '3d print' in original_query.lower() or 'printed' in original_query.lower() or 'printing' in original_query.lower():
                                        process_type = 'fdm'
                                        print(f"DEBUG: Detected 3D printing query: '{original_query}'")
                                    elif 'cnc' in original_query.lower() or 'machin' in original_query.lower() or 'mill' in original_query.lower():
                                        process_type = 'cnc'
                                        print(f"DEBUG: Detected CNC machining query: '{original_query}'")
                                
                                # Add process type to the response
                                if process_type:
                                    response['manufacturing_process'] = process_type
                                
                                dfm_response = {
                                    "response": self._format_dfm_response(response, part_name),
                                    "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
                                }
                                return dfm_response
                
                    return response
                except Exception as e:
                    print(f"Primary endpoint attempt {attempt} failed: {str(e)}")
                    if attempt < max_retries:
                        print(f"Waiting {retry_delay}s before retry...")
                        time.sleep(retry_delay)
                        retry_delay *= 2  # Exponential backoff
                    else:
                        first_error = e
            
            # If we get here, all primary endpoint attempts failed
            print("All primary endpoint attempts failed, trying fallbacks")
            
            # Try fallback endpoints if available
            if hasattr(self, 'config') and 'fallback_endpoints' in self.config:
                for endpoint in self.config['fallback_endpoints']:
                    try:
                        print(f"Trying fallback endpoint: {endpoint}")
                        response = self._make_request(endpoint, payload=payload)
                        return response
                    except Exception as e:
                        print(f"Fallback endpoint {endpoint} failed: {str(e)}")
            
            # If all endpoints fail, try the /api/chat endpoint as last resort
            try:
                print("Trying generic chat endpoint: /api/chat")
                chat_payload = {"message": message}
                response = self._make_request("/api/chat", payload=chat_payload)
                return response
            except Exception as e:
                print(f"Chat endpoint failed: {str(e)}")
                
                # Force reconnection attempt
                print("Attempting to reconnect to cloud service...")
                self.test_connection()
                
                # If reconnection successful, try one more time with the original endpoint
                if self.connected:
                    print("Reconnected successfully, retrying original request")
                    try:
                        response = self._make_request(endpoint, payload=request_payload)
                        return response
                    except Exception as retry_error:
                        print(f"Retry after reconnection failed: {str(retry_error)}")
                        
                # If we still can't connect, return a local fallback response
                return {
                    "response": "I'm processing your request locally. Cloud connection is currently unavailable.",
                    "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
                }
                
            # If we get here, all endpoints failed
            raise Exception(f"All endpoints failed. Primary error: {str(first_error)}")
        except Exception as e:
            self.last_error = str(e)
            # Update connection status if needed
            if self.connected:
                old_status = self.connected
                self.connected = False
                self.connection_quality = "unknown"
                if old_status != self.connected:
                    self._notify_connection_change()
            
            return {
                "error": str(e),
                "response": f"⚠️ Cloud connection error: {str(e)}. Please check your internet connection and API configuration.\n\nYou can click on the connection indicator to retry.",
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
            }
    
    def _get_cad_data(self) -> Dict[str, Any]:
        """Get CAD data from active document if available"""
        try:
            import FreeCAD
            
            if FreeCAD.ActiveDocument:
                doc = FreeCAD.ActiveDocument
                objects = doc.Objects
                
                # Basic document info
                doc_info = {
                    "name": doc.Name,
                    "object_count": len(objects),
                    "objects": []
                }
                
                # Get info about each object
                for obj in objects:
                    obj_info = {
                        "name": obj.Name,
                        "label": obj.Label,
                        "type": obj.TypeId
                    }
                    
                    # Add shape info if available
                    if hasattr(obj, 'Shape'):
                        bbox = obj.Shape.BoundBox
                        obj_info["dimensions"] = {
                            "x": bbox.XLength,
                            "y": bbox.YLength,
                            "z": bbox.ZLength
                        }
                        obj_info["volume"] = obj.Shape.Volume
                    
                    doc_info["objects"].append(obj_info)
                
                return doc_info
            else:
                return {"status": "no_active_document"}
                
        except Exception as e:
            print(f"Error getting CAD data: {e}")
            return {"status": "error", "message": str(e)}
    
    def _make_request(self, endpoint: str, payload: Dict[str, Any] = None, method: str = "POST", timeout: int = None) -> Dict[str, Any]:
        """Make a request to the cloud API"""
        url = f"{self.api_url}{endpoint}"
        
        # Set up headers with API key if available
        headers = {"Content-Type": "application/json"}
        if self.api_key:
            # Use X-API-Key as the primary authentication method
            # This is the standard expected by the cloud service
            headers["X-API-Key"] = self.api_key
            print("Using X-API-Key authentication")
        
        # Use provided timeout or default from config
        if timeout is None:
            cloud_config = self.load_cloud_config()
            timeout = cloud_config.get("connection_timeout", 10)
        
        try:
            print(f"Making {method} request to {url} with timeout {timeout}s")
            start_time = time.time()
            
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=timeout)
            elif method == "POST":
                response = requests.post(url, json=payload, headers=headers, timeout=timeout)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            # Calculate latency
            end_time = time.time()
            latency = int((end_time - start_time) * 1000)
            self.last_latency = latency
            
            # Log response status
            print(f"Response status code: {response.status_code}, latency: {latency}ms")
            
            # Check if response is successful
            if response.status_code >= 400:
                print(f"Error response: {response.text}")
                
                # Handle specific error codes
                if response.status_code == 401:
                    # Authentication error - try to recover
                    print("Authentication error. Trying to recover...")
                    # Reload config to get fresh API key
                    cloud_config = self.load_cloud_config()
                    self.api_key = cloud_config.get("cloud_api_key", "dev_api_key_for_testing")
                    raise ValueError(f"Authentication failed: {response.text}. Updated API key for next attempt.")
                elif response.status_code == 404:
                    # Not found error
                    raise ValueError(f"Endpoint not found: {endpoint}")
                elif response.status_code == 422 and 'cad_data' in response.text:
                    raise ValueError("API requires cad_data field")
            
            response.raise_for_status()
            
            # Update connection quality based on latency
            if latency < 200:
                self.connection_quality = "excellent"
            elif latency < 500:
                self.connection_quality = "good"
            elif latency < 1000:
                self.connection_quality = "fair"
            else:
                self.connection_quality = "poor"
            
            # Parse response
            return response.json()
            
        except requests.exceptions.RequestException as e:
            self.last_error = str(e)
            print(f"Cloud API request failed: {str(e)}")
            if hasattr(e, 'response') and e.response is not None:
                print(f"Response status code: {e.response.status_code}")
                try:
                    print(f"Response content: {e.response.text}")
                except:
                    pass
            # Update connection status
            old_status = self.connected
            self.connected = False
            self.connection_quality = "unknown"
            
            # Notify listeners if status changed
            if old_status and not self.connected:
                self._notify_connection_change()
                
            raise Exception(f"Cloud API request failed: {str(e)}")
        
        except Exception as e:
            self.last_error = str(e)
            print(f"Unexpected error: {str(e)}")
            raise

    def add_connection_listener(self, callback):
        """Add a callback function to be notified of connection status changes"""
        if callback not in self.connection_listeners:
            self.connection_listeners.append(callback)
    
    def remove_connection_listener(self, callback):
        """Remove a connection status callback"""
        if callback in self.connection_listeners:
            self.connection_listeners.remove(callback)
    
    def _notify_connection_change(self):
        """Notify all listeners of connection status change"""
        for callback in self.connection_listeners:
            try:
                callback(self.connected, self.connection_quality, self.last_latency)
            except Exception as e:
                print(f"Error in connection listener callback: {str(e)}")
                
    def _save_config_to_file(self):
        """Save the current configuration to the config file"""
        try:
            if hasattr(self, 'config'):
                script_dir = os.path.dirname(os.path.realpath(__file__))
                config_file = os.path.join(script_dir, "cloud_config.json")
                
                print(f"Saving updated configuration to {config_file}")
                with open(config_file, "w") as f:
                    json.dump(self.config, f, indent=2)
                print("Configuration saved successfully")
                return True
            return False
        except Exception as e:
            print(f"Error saving configuration: {str(e)}")
            return False
            
    def _format_dfm_response(self, analysis_result, part_name):
        """Format DFM analysis results into a user-friendly response with numbered list for better readability"""
        try:
            # Check if this is the new DFM endpoint response format
            if 'violations' in analysis_result:
                return self._format_new_dfm_response(analysis_result, part_name)
            else:
                # Use the existing formatter for the old response format
                return self._format_legacy_dfm_response(analysis_result, part_name)
        except Exception as e:
            print(f"Error formatting DFM response: {str(e)}")
            return f"Error formatting DFM analysis results: {str(e)}"
    
    def _format_new_dfm_response(self, analysis_result, part_name):
        """Format DFM analysis results from the new endpoint structure"""
        try:
            # Start with part name as a header
            response_text = f"DFM Analysis for {part_name}:\n\n"
            
            violations = analysis_result.get('violations', [])
            
            # Start numbered list
            item_num = 1
            
            # Add overall assessment
            if not violations:
                response_text += f"{item_num}. ✅ Overall: Excellent manufacturability\n"
            else:
                # Calculate overall severity based on highest severity score
                max_severity = max([v.get('severity_score', 0) for v in violations]) if violations else 0
                
                if max_severity >= 90:
                    response_text += f"{item_num}. 🚨 Overall: Critical manufacturability issues detected\n"
                elif max_severity >= 70:
                    response_text += f"{item_num}. ⚠️ Overall: Significant manufacturability issues detected\n"
                else:
                    response_text += f"{item_num}. ℹ️ Overall: Minor manufacturability issues detected\n"
            item_num += 1
            
            # Add process information
            process_name = "Unknown"
            
            # Try to get process from the response first
            if 'manufacturing_process' in analysis_result:
                process = analysis_result['manufacturing_process']
                if process == 'fdm':
                    process_name = "FDM 3D Printing"
                elif process == 'cnc':
                    process_name = "CNC Machining"
                elif process == 'injection_molding':
                    process_name = "Injection Molding"
            # Fall back to checking violations text
            elif violations and len(violations) > 0 and 'issue' in violations[0]:
                issue_text = violations[0]['issue'].lower()
                if 'fdm' in issue_text or '3d print' in issue_text or 'printing' in issue_text:
                    process_name = "FDM 3D Printing"
                    process = "fdm"
                elif 'cnc' in issue_text or 'machin' in issue_text or 'mill' in issue_text:
                    process_name = "CNC Machining"
                    process = "cnc"
            
            response_text += f"{item_num}. Manufacturing Process: {process_name}\n"
            item_num += 1
            
            # Add violations with severity indicators
            response_text += f"\n{item_num}. Manufacturability Issues:\n"
            item_num += 1
            
            if not violations:
                response_text += "   ✓ No specific manufacturability issues detected.\n"
            else:
                for i, violation in enumerate(violations, 1):
                    # Get severity and issue details
                    severity_score = violation.get('severity_score', 0)
                    issue = violation.get('issue', 'Unknown issue')
                    suggestion = violation.get('suggestion', '')
                    
                    # Choose emoji based on severity score
                    if severity_score >= 90:
                        emoji = "🚨"  # Red alert for critical issues
                    elif severity_score >= 70:
                        emoji = "⚠️"  # Warning for moderate issues
                    else:
                        emoji = "ℹ️"  # Info for minor issues
                    
                    # Format the issue and suggestion
                    issue_text = f"{emoji} {issue}"
                    if suggestion:
                        issue_text += f" - {suggestion}"
                    
                    response_text += f"   {i}. {issue_text}\n"
            
            return response_text
        except Exception as e:
            print(f"Error formatting new DFM response: {str(e)}")
            return f"Error formatting DFM analysis results: {str(e)}"
    
    def _format_legacy_dfm_response(self, analysis_result, part_name):
        """Format DFM analysis results from the legacy endpoint structure"""
        try:
            # Check if this is a 3D printing request by looking at the original query
            original_query = ''
            if 'original_query' in analysis_result:
                original_query = analysis_result.get('original_query', '').lower()
                print(f"DEBUG: Found original query in response: '{original_query}'")
            elif 'query_intent' in analysis_result:
                original_query = analysis_result.get('query_intent', {}).get('original_query', '').lower()
            
            # Force process detection from the original message
            process = ''
            if '3d print' in original_query or 'printed' in original_query or 'printing' in original_query:
                process = 'fdm'
                print("DEBUG: Forcing 3D printing specific formatting based on query")
            elif 'cnc' in original_query or 'machin' in original_query or 'mill' in original_query:
                process = 'cnc'
                print("DEBUG: Forcing CNC machining specific formatting based on query")
            
            # If we couldn't detect from query, try to get from response
            if not process:
                process = analysis_result.get('manufacturing_process', '')
                if not process and 'request_metadata' in analysis_result:
                    process = analysis_result.get('request_metadata', {}).get('manufacturing_process', '')
            
            # Default to generic if no process is specified
            process_name = "Manufacturing"
            
            # Force 3D printing specific response for 3D printing queries
            if '3d print' in original_query or 'printed' in original_query or 'printing' in original_query:
                process = 'fdm'
                process_name = "3D Printing (FDM)"
                print("DEBUG: Forcing 3D printing specific response format")
            # Force CNC machining specific response for machining queries
            elif 'cnc' in original_query or 'machin' in original_query or 'mill' in original_query:
                process = 'cnc'
                process_name = "CNC Machining"
                print("DEBUG: Forcing CNC machining specific response format")
            # Otherwise use the detected process
            elif process == 'fdm':
                process_name = "3D Printing (FDM)"
            elif process == 'cnc':
                process_name = "CNC Machining"
            elif process == 'injection_molding':
                process_name = "Injection Molding"
                
            # Start with part name and process as a header
            response_text = f"{process_name} Analysis for {part_name}:\n\n"
            
            # Get manufacturability index and complexity
            mfg_index = analysis_result.get('manufacturability_index', 0)
            complexity = analysis_result.get('manufacturing_features', {}).get('complexity_rating', 'Unknown')
            
            # Start numbered list
            item_num = 1
            
            # Add overall assessment as item #1 with process-specific wording
            if process == 'fdm':
                if mfg_index > 90:
                    response_text += f"{item_num}. ✅ Overall: Excellent 3D printability (Score: {mfg_index}/100)\n"
                elif mfg_index > 70:
                    response_text += f"{item_num}. ✓ Overall: Good 3D printability (Score: {mfg_index}/100)\n"
                elif mfg_index > 50:
                    response_text += f"{item_num}. ⚠️ Overall: Fair 3D printability (Score: {mfg_index}/100)\n"
                else:
                    response_text += f"{item_num}. 🚨 Overall: Poor 3D printability (Score: {mfg_index}/100)\n"
            elif process == 'cnc':
                if mfg_index > 90:
                    response_text += f"{item_num}. ✅ Overall: Excellent machinability (Score: {mfg_index}/100)\n"
                elif mfg_index > 70:
                    response_text += f"{item_num}. ✓ Overall: Good machinability (Score: {mfg_index}/100)\n"
                elif mfg_index > 50:
                    response_text += f"{item_num}. ⚠️ Overall: Fair machinability (Score: {mfg_index}/100)\n"
                else:
                    response_text += f"{item_num}. 🚨 Overall: Poor machinability (Score: {mfg_index}/100)\n"
            else:
                if mfg_index > 90:
                    response_text += f"{item_num}. ✅ Overall: Excellent manufacturability (Score: {mfg_index}/100)\n"
                elif mfg_index > 70:
                    response_text += f"{item_num}. ✓ Overall: Good manufacturability (Score: {mfg_index}/100)\n"
                elif mfg_index > 50:
                    response_text += f"{item_num}. ⚠️ Overall: Fair manufacturability (Score: {mfg_index}/100)\n"
                else:
                    response_text += f"{item_num}. 🚨 Overall: Poor manufacturability (Score: {mfg_index}/100)\n"
            item_num += 1
            
            # Add complexity as item #2 with process-specific context
            if process == 'fdm':
                response_text += f"{item_num}. Print Complexity: {complexity}\n"
                item_num += 1
                
                # Add 3D printing specific recommendations
                response_text += f"{item_num}. 3D Printing Recommendations:\n"
                response_text += f"   • Recommended material: PLA or ABS\n"
                response_text += f"   • Layer height: 0.2mm\n"
                response_text += f"   • Infill: 20-30%\n"
                if complexity.lower() == 'high':
                    response_text += f"   • Supports: Required\n"
                else:
                    response_text += f"   • Supports: Likely not needed\n"
            elif process == 'cnc':
                response_text += f"{item_num}. Machining Complexity: {complexity}\n"
                item_num += 1
                
                # Add CNC machining specific recommendations
                response_text += f"{item_num}. CNC Machining Recommendations:\n"
                response_text += f"   • Recommended material: Aluminum or mild steel\n"
                response_text += f"   • Minimum tool diameter: 3mm\n"
                if complexity.lower() == 'high':
                    response_text += f"   • Setup: Multi-axis machining recommended\n"
                else:
                    response_text += f"   • Setup: Standard 3-axis machining\n"
            else:
                response_text += f"{item_num}. Complexity: {complexity}\n"
            item_num += 1
            
            # Add design issues with severity indicators
            design_issues = analysis_result.get('design_issues', [])
            
            # For 3D printing queries, add specific 3D printing issues if none exist
            if process == 'fdm' and not design_issues:
                # Add some generic 3D printing considerations
                if analysis_result.get('dimensions', {}).get('z', 0) < 1.0:
                    design_issues.append("Layer height too thin - minimum 0.1mm recommended for FDM printing")
                elif analysis_result.get('dimensions', {}).get('z', 0) > 200:
                    design_issues.append("Model height exceeds typical build volume of many desktop 3D printers")
                
                # Add some generic 3D printing recommendations
                design_issues.append("Consider using PLA for easiest printing or ABS for better durability")
                design_issues.append("Print with 20% infill for a good balance of strength and material usage")
                design_issues.append("Orient the part for minimal support requirements")
            
            # Get the manufacturing process from the request or response
            process = analysis_result.get('manufacturing_process', '')
            if not process and 'request_metadata' in analysis_result:
                process = analysis_result.get('request_metadata', {}).get('manufacturing_process', '')
            
            # Process-specific section title
            if process == 'fdm':
                response_text += f"\n{item_num}. 3D Printing Considerations:\n"
            elif process == 'cnc':
                response_text += f"\n{item_num}. CNC Machining Considerations:\n"
            else:
                response_text += f"\n{item_num}. Manufacturability Issues:\n"
            item_num += 1
            
            if not design_issues:
                if process == 'fdm':
                    response_text += "   ✓ No specific 3D printing issues detected. The model appears to be printable.\n"
                    response_text += "   ℹ️ Recommended print settings: Layer height: 0.2mm, Infill: 20%, Support: No\n"
                elif process == 'cnc':
                    response_text += "   ✓ No specific CNC machining issues detected. The model appears to be machinable.\n"
                else:
                    response_text += "   ✓ No specific manufacturability issues detected.\n"
            else:
                for i, issue in enumerate(design_issues, 1):
                    # Determine severity based on keywords
                    severity = "info"
                    issue_text = issue.lower()
                    
                    if any(kw in issue_text for kw in ["critical", "severe", "cannot", "impossible", "fail"]):
                        severity = "critical"
                        emoji = "🚨"  # Red alert for critical issues
                    elif any(kw in issue_text for kw in ["warning", "recommend", "should", "consider", "improve"]):
                        severity = "warning"
                        emoji = "⚠️"  # Warning for moderate issues
                    else:
                        emoji = "ℹ️"  # Info for minor issues
                        
                    # Add process-specific context to generic issues
                    if process == 'fdm':
                        # Add 3D printing context to generic issues
                        if "thin" in issue_text or "thickness" in issue_text:
                            issue = f"{issue} (Critical for 3D printing - may cause print failure)"
                        elif "overhang" in issue_text:
                            issue = f"{issue} (May require supports during printing)"
                        elif "sharp" in issue_text or "corner" in issue_text:
                            issue = f"{issue} (Consider adding fillets for better print quality)"
                    elif process == 'cnc':
                        # Add CNC machining context to generic issues
                        if "internal corner" in issue_text or "sharp corner" in issue_text:
                            issue = f"{issue} (Not achievable with standard CNC tooling)"
                        elif "undercut" in issue_text:
                            issue = f"{issue} (May require multi-axis machining)"
                    
                    response_text += f"   {i}. {emoji} {issue}\n"
            
            # Add material recommendations
            materials = analysis_result.get('material_suggestions', [])
            if materials:
                response_text += f"\n{item_num}. Recommended Materials:\n"
                item_num += 1
                for i, material in enumerate(materials, 1):
                    response_text += f"   {i}. {material}\n"
            
            # Add process recommendations
            processes = analysis_result.get('process_recommendations', [])
            if processes:
                response_text += f"\n{item_num}. Recommended Manufacturing Processes:\n"
                for i, process in enumerate(processes, 1):
                    response_text += f"   {i}. {process}\n"
            
            return response_text
        except Exception as e:
            print(f"Error formatting DFM response: {str(e)}")
            return f"Error formatting DFM analysis results: {str(e)}"
    
    def get_connection_info(self):
        """Get detailed connection information"""
        return {
            "connected": self.connected,
            "quality": self.connection_quality,
            "latency": self.last_latency,
            "last_check": self.last_check_time,
            "last_error": self.last_error
        }

# Singleton cloud client instance
_cloud_client_instance = None

def get_cloud_client() -> CloudApiClient:
    """Get the singleton cloud client instance"""
    global _cloud_client_instance
    if _cloud_client_instance is None:
        _cloud_client_instance = CloudApiClient()
    return _cloud_client_instance

class StandaloneCoPilot(QtWidgets.QWidget):
    """Standalone Manufacturing Co-Pilot with built-in singleton pattern"""
    
    def __init__(self, parent=None):
        """Initialize the standalone co-pilot"""
        super().__init__(parent)
        
        # Connect to cloud
        self.cloud_client = get_cloud_client()
        self.cloud_connected = self.cloud_client.connected
        
        # Initialize NL CAD editor
        self.nl_cad_editor = NaturalLanguageCADEditor(self.cloud_client)
        print("Natural Language CAD Editor initialized")
        
        # Initialize Manufacturing Feature Manager for cloud features
        self.mfg_feature_manager = ManufacturingFeatureManager()
        print("Manufacturing Feature Manager initialized for cloud services")
        
        # Set up the UI
        self.setup_ui()
        
        # Register as connection listener
        self.cloud_client.add_connection_listener(self.update_status)
        
        # Update cloud status in UI with initial values
        conn_info = self.cloud_client.get_connection_info()
        self.update_status(
            conn_info["connected"],
            conn_info["quality"],
            conn_info["latency"]
        )
        
        # Set up periodic connection check
        self.connection_timer = QtCore.QTimer()
        self.connection_timer.timeout.connect(self.check_connection)
        self.connection_timer.start(60000)  # Check every minute
    
    def setup_ui(self):
        """Set up the user interface"""
        # Set window title and size
        self.setWindowTitle("Standalone Manufacturing Co-Pilot")
        self.resize(500, 600)
        
        # Set dark theme for the entire widget
        self.setStyleSheet("""
            QWidget {
                background-color: #333333;
                color: #E0E0E0;
            }
            QPushButton {
                background-color: #444444;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px;
                min-height: 25px;
            }
            QPushButton:hover {
                background-color: #555555;
            }
            QPushButton:pressed {
                background-color: #666666;
            }
            QLabel {
                color: #E0E0E0;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 5px;
            }
        """)
        
        # Create main layout
        layout = QtWidgets.QVBoxLayout()
        self.setLayout(layout)
        
        # Add header with logo and status
        header_layout = QtWidgets.QHBoxLayout()
        
        # Logo and title
        logo_label = QtWidgets.QLabel("🔧")
        logo_label.setStyleSheet("font-size: 24px;")
        title_label = QtWidgets.QLabel("Manufacturing Co-Pilot")
        title_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        
        # Status indicator
        self.status_layout = QtWidgets.QHBoxLayout()
        self.status_indicator = QtWidgets.QLabel("●")
        self.status_indicator.setStyleSheet("color: red;")
        self.status_text = QtWidgets.QLabel("Cloud: Disconnected")
        self.status_layout.addWidget(self.status_indicator)
        self.status_layout.addWidget(self.status_text)
        
        # Create tooltip with detailed connection info
        self.status_widget = QtWidgets.QWidget()
        self.status_widget.setLayout(self.status_layout)
        self.status_widget.setToolTip("Cloud connection status")
        
        # Add to header layout
        header_layout.addWidget(logo_label)
        header_layout.addWidget(title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.status_widget)
        
        # Make status clickable to retry connection
        self.status_widget.setCursor(QtCore.Qt.PointingHandCursor)
        self.status_widget.mousePressEvent = self.retry_connection
        
        # Add header to main layout
        layout.addLayout(header_layout)
        
        # Add chat history area
        self.chat_history = QtWidgets.QTextEdit()
        self.chat_history.setReadOnly(True)
        self.chat_history.setMinimumHeight(300)
        
        # Set dark theme colors for chat history - ensure dark background and light text
        self.chat_history.setStyleSheet("""
            QTextEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 4px;
            }
            QTextEdit QWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
            }
            QScrollBar:vertical {
                background-color: #2D2D2D;
                width: 14px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background-color: #555555;
                min-height: 20px;
                border-radius: 7px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        
        layout.addWidget(self.chat_history)
        
        # Add input area with send button
        input_layout = QtWidgets.QHBoxLayout()
        
        self.input_field = QtWidgets.QTextEdit()
        self.input_field.setPlaceholderText("Ask about manufacturing...")
        self.input_field.setMaximumHeight(100)
        
        # Set dark theme colors for input field - ensure dark background and light text
        self.input_field.setStyleSheet("""
            QTextEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 4px;
            }
            QTextEdit QWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
            }
            QScrollBar:vertical {
                background-color: #2D2D2D;
                width: 14px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background-color: #555555;
                min-height: 20px;
                border-radius: 7px;
            }
        """)
        
        input_layout.addWidget(self.input_field)
        
        self.send_button = QtWidgets.QPushButton("Send")
        self.send_button.clicked.connect(self.send_message)
        self.send_button.setMinimumHeight(80)
        input_layout.addWidget(self.send_button)
        
        layout.addLayout(input_layout)
        
        # Connect enter key to send message
        self.input_field.installEventFilter(self)
        
        # Add buttons
        button_layout = QtWidgets.QHBoxLayout()
        
        self.analyze_button = QtWidgets.QPushButton("Analyze")
        self.analyze_button.clicked.connect(self.on_analyze_clicked)
        
        self.suggestions_button = QtWidgets.QPushButton("Suggestions")
        self.suggestions_button.clicked.connect(self.on_suggestions_clicked)
        
        self.clear_button = QtWidgets.QPushButton("Clear")
        self.clear_button.clicked.connect(self.on_clear_clicked)
        
        button_layout.addWidget(self.analyze_button)
        button_layout.addWidget(self.suggestions_button)
        button_layout.addWidget(self.clear_button)
        
        layout.addLayout(button_layout)
        
        # Add cloud manufacturing features section
        self.add_manufacturing_features_ui(layout)
        
        # Add initial message
        self.add_system_message("Welcome to the Manufacturing Co-Pilot!")
        self.add_system_message("Ask questions about manufacturing or CAD design.")
        
        # Add cloud status message
        if self.cloud_connected:
            self.add_system_message(f"Connected to cloud service at {self.cloud_client.api_url}")
        else:
            self.add_system_message(f"Failed to connect to cloud service: {self.cloud_client.last_error}")
    
    def eventFilter(self, obj, event):
        """Handle events for input field"""
        if obj is self.input_field and event.type() == QtCore.QEvent.KeyPress:
            if event.key() == QtCore.Qt.Key_Return and not event.modifiers() & QtCore.Qt.ShiftModifier:
                self.send_message()
                return True
        return super().eventFilter(obj, event)
    
    def send_message(self):
        """Send a message to the cloud service"""
        message = self.input_field.toPlainText().strip()
        if not message:
            return
        
        # Add user message to chat history
        self.add_user_message(message)
        
        # Clear input field
        self.input_field.clear()
        
        # Show processing indicator
        self.add_system_message("Processing...")
        
        # Check if this is a CAD command
        if self.is_cad_command(message):
            self.process_cad_command(message)
        else:
            # Send message to cloud service for chat
            try:
                # Get response from cloud
                response = self.cloud_client.get_chat_response(message)
                
                # Extract response text
                if "response" in response:
                    response_text = response["response"]
                elif "error" in response:
                    response_text = f"Error: {response['error']}"
                else:
                    print(f"Debug: Received empty response from cloud: {response}")
                    response_text = "I'm processing your request locally."
                
                # Remove processing indicator
                self.remove_last_processing_message()
                
                # Add assistant message
                self.add_assistant_message(response_text)
                
            except Exception as e:
                # Remove processing indicator
                self.remove_last_processing_message()
                
                # Add error message
                self.add_system_message(f"Error: {str(e)}")
                print(f"Error sending message: {e}")
                traceback.print_exc()
    
    def is_cad_command(self, text):
        """Check if the text is a CAD command"""
        cad_indicators = [
            'create', 'make', 'add', 'generate',
            'box', 'cylinder', 'sphere', 'cube',
            'bracket', 'gear', 'housing', 'shaft',
            'extrude', 'extend', 'pull', 'fillet', 'round'
        ]
        
        text_lower = text.lower()
        return any(indicator in text_lower for indicator in cad_indicators)
    
    def process_cad_command(self, text):
        """Process a CAD command using the NL CAD editor"""
        try:
            # Remove processing indicator
            self.remove_last_processing_message()
            
            # Add system message
            self.add_system_message(f"Creating CAD model from: '{text}'")
            
            # Process command with NL CAD editor
            result = self.nl_cad_editor.process_command(text)
            
            if result['success']:
                # Add success message
                self.add_system_message(f"✅ {result['message']}")
                
                # Add assistant message with details
                self.add_assistant_message(f"I've created the CAD model based on your description. You can see it in the 3D view.")
            else:
                # Add error message
                self.add_system_message(f"❌ {result['message']}")
                
                # Add assistant message with error
                self.add_assistant_message(f"I couldn't create the CAD model. {result['message']}")
            
        except Exception as e:
            # Add error message
            self.add_system_message(f"Error processing CAD command: {str(e)}")
            traceback.print_exc()
    
    def update_status(self, connected, quality="unknown", latency=0):
        """Update the cloud connection status indicator"""
        if connected:
            # Set color based on connection quality
            if quality == "excellent":
                self.status_indicator.setStyleSheet("color: #00AA00;")  # Bright green
                status_text = "Cloud: Excellent"
            elif quality == "good":
                self.status_indicator.setStyleSheet("color: #00CC00;")  # Green
                status_text = "Cloud: Good"
            elif quality == "fair":
                self.status_indicator.setStyleSheet("color: #CCCC00;")  # Yellow
                status_text = "Cloud: Fair"
            elif quality == "poor":
                self.status_indicator.setStyleSheet("color: #CC6600;")  # Orange
                status_text = "Cloud: Poor"
            else:
                self.status_indicator.setStyleSheet("color: #00CC00;")  # Default green
                status_text = "Cloud: Connected"
                
            self.status_text.setText(status_text)
            self.cloud_connected = True
            
            # Update tooltip with detailed info
            tooltip = f"Cloud Status: {quality.title()}\nLatency: {latency}ms"
            self.status_widget.setToolTip(tooltip)
        else:
            self.status_indicator.setStyleSheet("color: red;")
            self.status_text.setText("Cloud: Disconnected")
            self.cloud_connected = False
            self.status_widget.setToolTip("Cloud connection failed. Click to retry.")
    
    def retry_connection(self, event):
        """Retry cloud connection when status indicator is clicked"""
        self.add_system_message("Retrying cloud connection...")
        success = self.cloud_client.test_connection()
        if success:
            self.add_system_message("Cloud connection restored!")
        else:
            self.add_system_message(f"Cloud connection failed: {self.cloud_client.last_error}")
    
    def check_connection(self):
        """Periodically check cloud connection"""
        # Only run check if more than 5 minutes since last check
        current_time = time.time()
        if current_time - self.cloud_client.last_check_time > 300:
            print("Performing periodic connection check")
            self.cloud_client.test_connection()
    
    def add_system_message(self, message):
        """Add a system message to the chat history"""
        timestamp = datetime.now().strftime("%H:%M")
        self.chat_history.append(f"<b>[{timestamp}] System:</b> {message}")
        
    def remove_last_processing_message(self):
        """Remove the last 'Processing...' message from chat history"""
        # Get current HTML content
        html = self.chat_history.toHtml()
        
        # Find and remove the last processing message
        processing_text = "<b>[\d+:\d+] System:</b> Processing..."
        import re
        html = re.sub(processing_text, "", html, count=1)
        
        # Set the modified HTML content
        self.chat_history.setHtml(html)
    
    def add_user_message(self, message):
        """Add a user message to the chat history"""
        timestamp = datetime.now().strftime("%H:%M")
        self.chat_history.append(f"<b>[{timestamp}] You:</b> {message}")
    
    def add_assistant_message(self, message):
        """Add an assistant message to the chat history"""
        timestamp = datetime.now().strftime("%H:%M")
        self.chat_history.append(f"<b>[{timestamp}] Manufacturing Co-Pilot:</b> {message}")
    
    def on_analyze_clicked(self):
        """Handle analyze button click"""
        self.add_system_message("Analyzing current model...")
        try:
            # Check if there's an active document
            if FreeCAD.ActiveDocument:
                doc_name = FreeCAD.ActiveDocument.Name
                objects = FreeCAD.ActiveDocument.Objects
                object_count = len(objects)
                
                # Basic analysis
                analysis_text = f"Active document: {doc_name} with {object_count} objects\n"
                
                # Analyze each object
                for obj in objects:
                    if hasattr(obj, 'Shape'):
                        # Get basic properties
                        volume = obj.Shape.Volume
                        bbox = obj.Shape.BoundBox
                        dimensions = f"{bbox.XLength:.1f}x{bbox.YLength:.1f}x{bbox.ZLength:.1f}"
                        
                        analysis_text += f"- {obj.Label}: {obj.TypeId}, Volume: {volume:.1f} mm³, Size: {dimensions} mm\n"
                    else:
                        analysis_text += f"- {obj.Label}: {obj.TypeId}\n"
                
                # Add analysis to chat
                self.add_assistant_message(f"Here's my analysis of the current model:\n\n{analysis_text}")
            else:
                self.add_system_message("No active document found")
                self.add_assistant_message("There is no active document to analyze. Please create or open a document first.")
        except Exception as e:
            self.add_system_message(f"Error analyzing model: {str(e)}")
            traceback.print_exc()
    
    def on_suggestions_clicked(self):
        """Handle suggestions button click"""
        self.add_system_message("Generating CAD suggestions...")
        
        # Suggest some CAD commands
        suggestions = [
            "Create a box 100x50x20",
            "Make a cylinder with diameter 30 and height 50",
            "Create a bracket with mounting holes",
            "Generate a gear with 20 teeth"
        ]
        
        # Add suggestions to chat
        self.add_assistant_message("Here are some CAD commands you can try:\n\n" + 
                               "\n".join([f"- {s}" for s in suggestions]) + 
                               "\n\nJust type one of these commands or create your own!")
        
        # Set a random suggestion in the input field
        self.input_field.setText(random.choice(suggestions))
    
    def on_clear_clicked(self):
        """Handle clear button click"""
        self.chat_history.clear()
        self.add_system_message("Chat history cleared.")
        
    def add_manufacturing_features_ui(self, layout):
        """Add cloud manufacturing features UI elements"""
        # Create group box for manufacturing features
        mfg_group = QtWidgets.QGroupBox("Cloud Manufacturing Features")
        mfg_layout = QtWidgets.QVBoxLayout()
        
        # Add description label
        desc_label = QtWidgets.QLabel("Access cloud-based manufacturing intelligence:")
        mfg_layout.addWidget(desc_label)
        
        # Create button grid layout
        button_grid = QtWidgets.QGridLayout()
        
        # DFM Analysis button
        self.dfm_button = QtWidgets.QPushButton("DFM Analysis")
        self.dfm_button.setToolTip("Analyze design for manufacturability issues")
        self.dfm_button.clicked.connect(self.on_dfm_clicked)
        button_grid.addWidget(self.dfm_button, 0, 0)
        
        # Cost Estimation button
        self.cost_button = QtWidgets.QPushButton("Cost Estimation")
        self.cost_button.setToolTip("Estimate manufacturing costs")
        self.cost_button.clicked.connect(self.on_cost_clicked)
        button_grid.addWidget(self.cost_button, 0, 1)
        
        # Tool Recommendations button
        self.tools_button = QtWidgets.QPushButton("Tool Recommendations")
        self.tools_button.setToolTip("Get tool and machining recommendations")
        self.tools_button.clicked.connect(self.on_tools_clicked)
        button_grid.addWidget(self.tools_button, 1, 0)
        
        # Manufacturing Method Comparison button
        self.compare_button = QtWidgets.QPushButton("Compare Methods")
        self.compare_button.setToolTip("Compare different manufacturing methods")
        self.compare_button.clicked.connect(self.on_compare_clicked)
        button_grid.addWidget(self.compare_button, 1, 1)
        
        # Add button grid to layout
        mfg_layout.addLayout(button_grid)
        
        # Add status indicator for cloud features
        cloud_status_layout = QtWidgets.QHBoxLayout()
        self.cloud_feature_status = QtWidgets.QLabel("Ready")
        cloud_status_layout.addWidget(QtWidgets.QLabel("Status:"))
        cloud_status_layout.addWidget(self.cloud_feature_status)
        cloud_status_layout.addStretch()
        mfg_layout.addLayout(cloud_status_layout)
        
        # Set the layout to the group box
        mfg_group.setLayout(mfg_layout)
        
        # Add the group box to the main layout
        layout.addWidget(mfg_group)
    
    def on_dfm_clicked(self):
        """Handle DFM analysis button click"""
        self.add_system_message("Running DFM analysis...")
        try:
            # Check if there's an active document
            if not FreeCAD.ActiveDocument:
                self.add_system_message("No active document found")
                self.add_assistant_message("Please open or create a model before running DFM analysis.")
                return
                
            # Update status
            self.cloud_feature_status.setText("Processing DFM analysis...")
            
            # Run DFM analysis using the manufacturing feature manager
            result = self.mfg_feature_manager.analyze_dfm()
            
            if result and result.get('success'):
                # Format the DFM results for display
                score = result.get('manufacturability_score', 0)
                issues = result.get('issues', [])
                recommendations = result.get('recommendations', [])
                
                # Create a formatted message
                message = f"<b>DFM Analysis Results</b><br>"
                message += f"<b>Manufacturability Score:</b> {score}/100<br><br>"
                
                if issues:
                    message += "<b>Issues Found:</b><br>"
                    for i, issue in enumerate(issues):
                        severity = issue.get('severity', 'medium')
                        color = "red" if severity == "high" else "orange" if severity == "medium" else "green"
                        message += f"<span style='color:{color}'>{i+1}. {issue.get('description')}</span><br>"
                    message += "<br>"
                else:
                    message += "<b>No manufacturability issues found.</b><br><br>"
                
                if recommendations:
                    message += "<b>Recommendations:</b><br>"
                    for i, rec in enumerate(recommendations):
                        message += f"{i+1}. {rec}<br>"
                
                # Add the formatted message to chat
                self.add_assistant_message(message)
                
                # Visualize issues if available
                if issues and hasattr(self.mfg_feature_manager, 'visualize_dfm_issues'):
                    self.mfg_feature_manager.visualize_dfm_issues(issues)
                    self.add_system_message("DFM issues visualized in the 3D view.")
            else:
                error_msg = result.get('error', 'Unknown error during DFM analysis') if result else "Failed to get DFM analysis results"
                self.add_system_message(f"Error: {error_msg}")
                self.add_assistant_message("I couldn't complete the DFM analysis. Please check if your model is valid and try again.")
        except Exception as e:
            self.add_system_message(f"Error during DFM analysis: {str(e)}")
            traceback.print_exc()
        finally:
            # Reset status
            self.cloud_feature_status.setText("Ready")
    
    def on_cost_clicked(self):
        """Handle cost estimation button click"""
        self.add_system_message("Running cost estimation...")
        try:
            # Check if there's an active document
            if not FreeCAD.ActiveDocument:
                self.add_system_message("No active document found")
                self.add_assistant_message("Please open or create a model before running cost estimation.")
                return
                
            # Update status
            self.cloud_feature_status.setText("Processing cost estimation...")
            
            # Run cost estimation using the manufacturing feature manager
            result = self.mfg_feature_manager.estimate_cost()
            
            if result and result.get('success'):
                # Format the cost results for display
                total_cost = result.get('total_cost', 0)
                currency = result.get('currency', 'USD')
                breakdown = result.get('cost_breakdown', {})
                optimization = result.get('optimization_suggestions', [])
                
                # Create a formatted message
                message = f"<b>Cost Estimation Results</b><br>"
                message += f"<b>Total Estimated Cost:</b> {currency} {total_cost:.2f}<br><br>"
                
                if breakdown:
                    message += "<b>Cost Breakdown:</b><br>"
                    for category, amount in breakdown.items():
                        message += f"{category}: {currency} {float(amount):.2f}<br>"
                    message += "<br>"
                
                if optimization:
                    message += "<b>Cost Optimization Suggestions:</b><br>"
                    for i, suggestion in enumerate(optimization):
                        message += f"{i+1}. {suggestion}<br>"
                
                # Add the formatted message to chat
                self.add_assistant_message(message)
            else:
                error_msg = result.get('error', 'Unknown error during cost estimation') if result else "Failed to get cost estimation results"
                self.add_system_message(f"Error: {error_msg}")
                self.add_assistant_message("I couldn't complete the cost estimation. Please check if your model is valid and try again.")
        except Exception as e:
            self.add_system_message(f"Error during cost estimation: {str(e)}")
            traceback.print_exc()
        finally:
            # Reset status
            self.cloud_feature_status.setText("Ready")
    
    def on_tools_clicked(self):
        """Handle tool recommendations button click"""
        self.add_system_message("Getting tool recommendations...")
        try:
            # Check if there's an active document
            if not FreeCAD.ActiveDocument:
                self.add_system_message("No active document found")
                self.add_assistant_message("Please open or create a model before getting tool recommendations.")
                return
                
            # Update status
            self.cloud_feature_status.setText("Processing tool recommendations...")
            
            # Get tool recommendations using the manufacturing feature manager
            result = self.mfg_feature_manager.recommend_tools()
            
            if result and result.get('success'):
                # Format the tool recommendations for display
                tools = result.get('recommended_tools', [])
                parameters = result.get('machining_parameters', {})
                
                # Create a formatted message
                message = f"<b>Tool Recommendations</b><br><br>"
                
                if tools:
                    message += "<b>Recommended Tools:</b><br>"
                    for i, tool in enumerate(tools):
                        tool_name = tool.get('name', f"Tool {i+1}")
                        tool_type = tool.get('type', 'Unknown')
                        diameter = tool.get('diameter', 0)
                        message += f"{i+1}. {tool_name} ({tool_type}, {diameter}mm)<br>"
                    message += "<br>"
                else:
                    message += "<b>No specific tools recommended.</b><br><br>"
                
                if parameters:
                    message += "<b>Machining Parameters:</b><br>"
                    for param, value in parameters.items():
                        message += f"{param}: {value}<br>"
                
                # Add the formatted message to chat
                self.add_assistant_message(message)
                
                # Visualize tool paths if available
                if hasattr(self.mfg_feature_manager, 'visualize_tool_paths'):
                    self.mfg_feature_manager.visualize_tool_paths()
                    self.add_system_message("Tool paths visualized in the 3D view.")
            else:
                error_msg = result.get('error', 'Unknown error getting tool recommendations') if result else "Failed to get tool recommendations"
                self.add_system_message(f"Error: {error_msg}")
                self.add_assistant_message("I couldn't get tool recommendations. Please check if your model is valid and try again.")
        except Exception as e:
            self.add_system_message(f"Error getting tool recommendations: {str(e)}")
            traceback.print_exc()
        finally:
            # Reset status
            self.cloud_feature_status.setText("Ready")
    
    def on_compare_clicked(self):
        """Handle manufacturing method comparison button click"""
        self.add_system_message("Comparing manufacturing methods...")
        try:
            # Check if there's an active document
            if not FreeCAD.ActiveDocument:
                self.add_system_message("No active document found")
                self.add_assistant_message("Please open or create a model before comparing manufacturing methods.")
                return
                
            # Update status
            self.cloud_feature_status.setText("Comparing manufacturing methods...")
            
            # Compare manufacturing methods using the manufacturing feature manager
            result = self.mfg_feature_manager.compare_manufacturing_methods()
            
            if result and result.get('success'):
                # Format the comparison results for display
                comparisons = result.get('comparisons', [])
                recommendation = result.get('recommended_method', {})
                
                # Create a formatted message
                message = f"<b>Manufacturing Method Comparison</b><br><br>"
                
                if recommendation:
                    method_name = recommendation.get('name', 'Unknown')
                    reason = recommendation.get('reason', 'No specific reason provided')
                    message += f"<b>Recommended Method:</b> {method_name}<br>"
                    message += f"<b>Reason:</b> {reason}<br><br>"
                
                if comparisons:
                    message += "<b>Method Comparison:</b><br>"
                    message += "<table border='1' cellpadding='3' style='border-collapse: collapse;'>"
                    message += "<tr><th>Method</th><th>Cost</th><th>Time</th><th>Quality</th><th>Suitability</th></tr>"
                    
                    for comp in comparisons:
                        method = comp.get('method', 'Unknown')
                        cost = comp.get('cost', 'N/A')
                        time = comp.get('time', 'N/A')
                        quality = comp.get('quality', 'N/A')
                        suitability = comp.get('suitability', 0)
                        
                        # Convert suitability to stars
                        stars = '★' * int(suitability) + '☆' * (5 - int(suitability))
                        
                        message += f"<tr><td>{method}</td><td>{cost}</td><td>{time}</td><td>{quality}</td><td>{stars}</td></tr>"
                    
                    message += "</table>"
                
                # Add the formatted message to chat
                self.add_assistant_message(message)
            else:
                error_msg = result.get('error', 'Unknown error comparing manufacturing methods') if result else "Failed to compare manufacturing methods"
                self.add_system_message(f"Error: {error_msg}")
                self.add_assistant_message("I couldn't compare manufacturing methods. Please check if your model is valid and try again.")
        except Exception as e:
            self.add_system_message(f"Error comparing manufacturing methods: {str(e)}")
            traceback.print_exc()
        finally:
            # Reset status
            self.cloud_feature_status.setText("Ready")

    
    def closeEvent(self, event):
        """Handle window close event"""
        global _STANDALONE_INSTANCE
        print("Closing Standalone Co-Pilot")
        _STANDALONE_INSTANCE = None
        event.accept()

class StandaloneCoPilotTaskPanel:
    """Task panel for the Standalone Co-Pilot"""
    
    def __init__(self, widget):
        """Initialize the task panel"""
        self.form = widget
        self.widget = widget
        print("StandaloneCoPilotTaskPanel initialized")
    
    def accept(self):
        """Handle accept event"""
        print("StandaloneCoPilotTaskPanel accepted")
        self._cleanup()
        return True
    
    def reject(self):
        """Handle reject event"""
        print("StandaloneCoPilotTaskPanel rejected")
        self._cleanup()
        return True
    
    def _cleanup(self):
        """Clean up resources"""
        global _STANDALONE_INSTANCE
        _STANDALONE_INSTANCE = None
        print("Reset _STANDALONE_INSTANCE to None")
    
    def getStandardButtons(self):
        """Return standard buttons"""
        return 0

def show_standalone_copilot():
    """Show the standalone co-pilot with singleton pattern"""
    global _STANDALONE_INSTANCE
    
    print("\n=== STARTING STANDALONE CO-PILOT ===\n")
    
    # Check if an instance already exists
    if _STANDALONE_INSTANCE is not None:
        print("Standalone Co-Pilot is already running - activating existing instance")
        try:
            # Try to bring existing instance to front
            _STANDALONE_INSTANCE.activateWindow()
            _STANDALONE_INSTANCE.raise_()
            
            # Show message to user
            QtWidgets.QMessageBox.information(
                None,
                "Co-Pilot Already Running",
                "Manufacturing Co-Pilot is already running. Using the existing instance."
            )
        except Exception as e:
            print(f"Error activating existing instance: {e}")
        return
    
    try:
        # Close any active FreeCAD task dialogs
        if FreeCADGui.Control.activeDialog():
            print("Closing active FreeCAD task dialog")
            FreeCADGui.Control.closeDialog()
        
        # Create new instance
        copilot = StandaloneCoPilot()
        _STANDALONE_INSTANCE = copilot
        
        # Show in FreeCAD task panel
        panel = StandaloneCoPilotTaskPanel(copilot)
        FreeCADGui.Control.showDialog(panel)
        print("Standalone Co-Pilot shown in task panel")
        
        print("\n=== STANDALONE CO-PILOT STARTED SUCCESSFULLY ===\n")
    except Exception as e:
        print(f"Error showing Standalone Co-Pilot: {e}")
        traceback.print_exc()
        _STANDALONE_INSTANCE = None
        
        # Show error message
        QtWidgets.QMessageBox.critical(
            None,
            "Co-Pilot Error",
            f"Failed to start Standalone Co-Pilot:\n\n{str(e)}"
        )

# Main entry point
if __name__ == "__main__":
    print("\n=== STANDALONE CO-PILOT MACRO STARTING ===\n")
    
    try:
        # Show the standalone co-pilot
        show_standalone_copilot()
    except Exception as e:
        print(f"ERROR starting Standalone Co-Pilot: {e}")
        traceback.print_exc()
        
        # Show error message
        try:
            QtWidgets.QMessageBox.critical(
                None,
                "Co-Pilot Error",
                f"Failed to start Standalone Co-Pilot:\n\n{str(e)}"
            )
        except Exception as msg_err:
            print(f"Error showing message: {msg_err}")
    
    print("\n=== STANDALONE CO-PILOT MACRO INITIALIZATION COMPLETE ===\n")
