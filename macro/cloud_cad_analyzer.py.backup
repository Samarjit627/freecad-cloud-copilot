"""
Cloud-based CAD Analyzer for the FreeCAD Manufacturing Co-Pilot
Extracts minimal data locally and sends to cloud for intensive analysis
"""

import os
import json
import time
from typing import Dict, Any, List, Tuple, Optional

import FreeCAD
import Part

# Import local modules
try:
    from . import cloud_client
    from . import local_cad_analyzer
    from . import config
except ImportError:
    import cloud_client
    import local_cad_analyzer
    import config

class CloudCADAnalyzer:
    """Cloud-based CAD analyzer that offloads intensive processing to Google Cloud Run"""
    
    def __init__(self):
        """Initialize the cloud CAD analyzer"""
        self.cloud_client = cloud_client.get_client()
        self.last_analysis = None
        self.is_analyzing = False
    
    def analyze_document(self, document) -> Dict[str, Any]:
        """
        Analyze a FreeCAD document using cloud-based analysis with local fallback
        
        Args:
            document: FreeCAD document to analyze
            
        Returns:
            Dict containing analysis results
        """
        try:
            self.is_analyzing = True
            
            # Extract basic metadata locally (lightweight operation)
            basic_metadata = self._extract_basic_metadata(document)
            
            # Prepare geometry data for cloud processing
            geometry_data = self._prepare_geometry_data(document)
            
            # First try cloud analysis
            try:
                print("Attempting cloud-based CAD analysis...")
                # This will throw an exception if all endpoints fail
                analysis_result = self.cloud_client.analyze_cad(basic_metadata, geometry_data)
                
                # If we get here, cloud analysis succeeded
                analysis_result["analysis_type"] = "cloud"
                
                # Only print success message if we actually got a result
                if "error" not in analysis_result:
                    print("✅ Cloud analysis successful!")
                    if hasattr(self.cloud_client, 'last_successful_endpoint') and self.cloud_client.last_successful_endpoint:
                        print(f"Used endpoint: {self.cloud_client.last_successful_endpoint}")
                
                # Store the result
                self.last_analysis = analysis_result
                self.is_analyzing = False
                
                return analysis_result
                
            except Exception as cloud_error:
                # Cloud analysis failed, fall back to local analysis
                print(f"Error in cloud CAD analysis: {str(cloud_error)}")
                print("⚠️ Falling back to local CAD analysis...")
                
                # Get local analyzer and run analysis
                local_analyzer = local_cad_analyzer.get_analyzer()
                local_result = local_analyzer.analyze_document(document)
                
                # Add a note about the fallback and explicitly set analysis type to local
                local_result["analysis_type"] = "local"
                local_result["cloud_error"] = str(cloud_error)
                local_result["note"] = "Cloud analysis unavailable. Using limited local analysis."
                
                # Store the result
                self.last_analysis = local_result
                self.is_analyzing = False
                
                return local_result
                
        except Exception as e:
            self.is_analyzing = False
            print(f"Error in cloud CAD analysis: {str(e)}")
            return {
                "error": str(e),
                "metadata": basic_metadata if 'basic_metadata' in locals() else {},
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
            }
    
    def _extract_basic_metadata(self, document) -> Dict[str, Any]:
        """
        Extract basic metadata from the document (lightweight local operation)
        
        Args:
            document: FreeCAD document
            
        Returns:
            Dict containing basic metadata
        """
        metadata = {
            "name": document.Name,
            "label": document.Label if hasattr(document, "Label") else document.Name,
            "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S"),
            "object_count": len(document.Objects)
        }
        
        # Get bounding box for basic dimensions (lightweight operation)
        try:
            shapes = []
            for obj in document.Objects:
                if hasattr(obj, "Shape"):
                    shapes.append(obj.Shape)
            
            if shapes:
                # Create a compound shape
                compound = Part.makeCompound(shapes)
                bbox = compound.BoundBox
                
                # Add bounding box dimensions
                metadata["dimensions"] = [
                    bbox.XLength,
                    bbox.YLength,
                    bbox.ZLength
                ]
                
                # Add bounding box volume (approximate)
                metadata["bounding_volume"] = bbox.XLength * bbox.YLength * bbox.ZLength
        except Exception as e:
            print(f"Warning: Could not calculate bounding box: {str(e)}")
        
        return metadata
    
    def _prepare_geometry_data(self, document) -> Dict[str, Any]:
        """
        Prepare geometry data for cloud processing
        This extracts essential geometry information without sending the full CAD model
        
        Args:
            document: FreeCAD document
            
        Returns:
            Dict containing geometry data for cloud processing
        """
        geometry_data = {
            "faces": [],
            "edges": []
        }
        
        try:
            # Process each object with a shape
            for obj in document.Objects:
                if not hasattr(obj, "Shape"):
                    continue
                    
                shape = obj.Shape
                obj_data = {
                    "name": obj.Name,
                    "label": obj.Label if hasattr(obj, "Label") else obj.Name,
                    "type": obj.TypeId,
                    "faces": [],
                    "edges": []
                }
                
                # Extract face data (simplified for cloud transmission)
                for i, face in enumerate(shape.Faces):
                    face_data = {
                        "index": i,
                        "area": face.Area,
                        "type": self._detect_face_type(face),
                        "center": [p for p in face.CenterOfMass],
                        "normal": [n for n in face.normalAt(0, 0)]
                    }
                    obj_data["faces"].append(face_data)
                
                # Extract edge data (simplified)
                for i, edge in enumerate(shape.Edges):
                    if hasattr(edge, "Vertexes") and len(edge.Vertexes) >= 2:
                        edge_data = {
                            "index": i,
                            "length": edge.Length,
                            "type": edge.Curve.TypeId if hasattr(edge, "Curve") else "Unknown",
                            "points": [
                                [p for p in edge.Vertexes[0].Point],
                                [p for p in edge.Vertexes[-1].Point]
                            ]
                        }
                        obj_data["edges"].append(edge_data)
                
                # Add to overall geometry data
                geometry_data["faces"].extend(obj_data["faces"])
                geometry_data["edges"].extend(obj_data["edges"])
            
            return geometry_data
            
        except Exception as e:
            print(f"Error preparing geometry data: {str(e)}")
            return geometry_data
    
    def _detect_face_type(self, face) -> str:
        """
        Detect the type of a face
        
        Args:
            face: FreeCAD face
            
        Returns:
            String describing the face type
        """
        try:
            surface = face.Surface
            surface_type = surface.TypeId
            
            # Map common surface types
            if "Plane" in surface_type:
                return "planar"
            elif "Cylinder" in surface_type:
                return "cylindrical"
            elif "Cone" in surface_type:
                return "conical"
            elif "Sphere" in surface_type:
                return "spherical"
            elif "Torus" in surface_type:
                return "toroidal"
            elif "BSpline" in surface_type:
                return "bspline"
            else:
                return surface_type
        except:
            return "unknown"

# Singleton instance
_analyzer_instance = None

def get_analyzer() -> CloudCADAnalyzer:
    """Get the singleton cloud CAD analyzer instance"""
    global _analyzer_instance
    if _analyzer_instance is None:
        _analyzer_instance = CloudCADAnalyzer()
    return _analyzer_instance
